{"ast":null,"code":"import dagre from 'dagre';\nexport function jsonToFlow(rootObj) {\n  let nodes = [];\n  let edges = [];\n  let counter = 0;\n  const safeId = path => path.replace(/[^a-zA-Z0-9_\\-$]/g, '_');\n  function visit(value, path = '$', depth = 0, label = null, parent = null) {\n    const id = safeId(path);\n    const nodeLabel = label === null ? 'root' : String(label);\n    const raw = typeof value === 'object' && value !== null ? JSON.stringify(value) : String(value);\n    nodes.push({\n      id,\n      data: {\n        label: nodeLabel,\n        path,\n        value,\n        raw\n      },\n      position: {\n        x: 0,\n        y: 0\n      },\n      // layout calculated later\n      type: 'default',\n      style: {\n        borderRadius: 8,\n        padding: 8,\n        border: '1px solid #ccc',\n        background: typeof value === 'object' ? Array.isArray(value) ? '#D1FAE5' // greenish for arrays\n        : '#DBEAFE' // blue for objects\n        : '#FEF3C7' // yellow for primitives\n      }\n    });\n    if (parent) {\n      edges.push({\n        id: `e-${parent}-${id}`,\n        source: safeId(parent),\n        target: id,\n        animated: true,\n        style: {\n          stroke: '#888',\n          strokeWidth: 2\n        }\n      });\n    }\n    if (value !== null && typeof value === 'object') {\n      if (Array.isArray(value)) {\n        value.forEach((item, idx) => visit(item, `${path}[${idx}]`, depth + 1, `[${idx}]`, path));\n      } else {\n        Object.keys(value).forEach(k => visit(value[k], `${path}.${k}`, depth + 1, k, path));\n      }\n    }\n    counter++;\n  }\n  visit(rootObj);\n\n  // Use dagre layout to position nodes and edges\n  const g = new dagre.graphlib.Graph();\n  g.setGraph({\n    rankdir: 'TB',\n    nodesep: 80,\n    ranksep: 100\n  });\n  g.setDefaultEdgeLabel(() => ({}));\n  nodes.forEach(node => g.setNode(node.id, {\n    width: 180,\n    height: 50\n  }));\n  edges.forEach(edge => g.setEdge(edge.source, edge.target));\n  dagre.layout(g);\n  nodes = nodes.map(node => {\n    const pos = g.node(node.id);\n    return {\n      ...node,\n      position: {\n        x: pos.x,\n        y: pos.y\n      }\n    };\n  });\n  return {\n    nodes,\n    edges\n  };\n}","map":{"version":3,"names":["dagre","jsonToFlow","rootObj","nodes","edges","counter","safeId","path","replace","visit","value","depth","label","parent","id","nodeLabel","String","raw","JSON","stringify","push","data","position","x","y","type","style","borderRadius","padding","border","background","Array","isArray","source","target","animated","stroke","strokeWidth","forEach","item","idx","Object","keys","k","g","graphlib","Graph","setGraph","rankdir","nodesep","ranksep","setDefaultEdgeLabel","node","setNode","width","height","edge","setEdge","layout","map","pos"],"sources":["C:/Users/abhis/OneDrive/Desktop/JSON TREE VISUALIZER/json-tree-visualizer/src/components/FlowTree.jsx"],"sourcesContent":["import dagre from 'dagre';\n\nexport function jsonToFlow(rootObj) {\n  let nodes = [];\n  let edges = [];\n  let counter = 0;\n\n  const safeId = (path) => path.replace(/[^a-zA-Z0-9_\\-$]/g, '_');\n\n  function visit(value, path = '$', depth = 0, label = null, parent = null) {\n    const id = safeId(path);\n    const nodeLabel = label === null ? 'root' : String(label);\n    const raw =\n      typeof value === 'object' && value !== null\n        ? JSON.stringify(value)\n        : String(value);\n\n    nodes.push({\n      id,\n      data: { label: nodeLabel, path, value, raw },\n      position: { x: 0, y: 0 }, // layout calculated later\n      type: 'default',\n      style: {\n        borderRadius: 8,\n        padding: 8,\n        border: '1px solid #ccc',\n        background:\n          typeof value === 'object'\n            ? Array.isArray(value)\n              ? '#D1FAE5' // greenish for arrays\n              : '#DBEAFE' // blue for objects\n            : '#FEF3C7', // yellow for primitives\n      },\n    });\n\n    if (parent) {\n      edges.push({\n        id: `e-${parent}-${id}`,\n        source: safeId(parent),\n        target: id,\n        animated: true,\n        style: { stroke: '#888', strokeWidth: 2 },\n      });\n    }\n\n    if (value !== null && typeof value === 'object') {\n      if (Array.isArray(value)) {\n        value.forEach((item, idx) =>\n          visit(item, `${path}[${idx}]`, depth + 1, `[${idx}]`, path)\n        );\n      } else {\n        Object.keys(value).forEach((k) =>\n          visit(value[k], `${path}.${k}`, depth + 1, k, path)\n        );\n      }\n    }\n\n    counter++;\n  }\n\n  visit(rootObj);\n\n  // Use dagre layout to position nodes and edges\n  const g = new dagre.graphlib.Graph();\n  g.setGraph({ rankdir: 'TB', nodesep: 80, ranksep: 100 });\n  g.setDefaultEdgeLabel(() => ({}));\n\n  nodes.forEach((node) => g.setNode(node.id, { width: 180, height: 50 }));\n  edges.forEach((edge) => g.setEdge(edge.source, edge.target));\n  dagre.layout(g);\n\n  nodes = nodes.map((node) => {\n    const pos = g.node(node.id);\n    return {\n      ...node,\n      position: { x: pos.x, y: pos.y },\n    };\n  });\n\n  return { nodes, edges };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}