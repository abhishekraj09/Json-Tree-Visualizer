{"ast":null,"code":"/**\n * @implements {IHooks}\n */\nclass Hooks {\n  /**\n   * @callback HookCallback\n   * @this {*|Jsep} this\n   * @param {Jsep} env\n   * @returns: void\n   */\n  /**\n   * Adds the given callback to the list of callbacks for the given hook.\n   *\n   * The callback will be invoked when the hook it is registered for is run.\n   *\n   * One callback function can be registered to multiple hooks and the same hook multiple times.\n   *\n   * @param {string|object} name The name of the hook, or an object of callbacks keyed by name\n   * @param {HookCallback|boolean} callback The callback function which is given environment variables.\n   * @param {?boolean} [first=false] Will add the hook to the top of the list (defaults to the bottom)\n   * @public\n   */\n  add(name, callback, first) {\n    if (typeof arguments[0] != 'string') {\n      // Multiple hook callbacks, keyed by name\n      for (let name in arguments[0]) {\n        this.add(name, arguments[0][name], arguments[1]);\n      }\n    } else {\n      (Array.isArray(name) ? name : [name]).forEach(function (name) {\n        this[name] = this[name] || [];\n        if (callback) {\n          this[name][first ? 'unshift' : 'push'](callback);\n        }\n      }, this);\n    }\n  }\n\n  /**\n   * Runs a hook invoking all registered callbacks with the given environment variables.\n   *\n   * Callbacks will be invoked synchronously and in the order in which they were registered.\n   *\n   * @param {string} name The name of the hook.\n   * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\n   * @public\n   */\n  run(name, env) {\n    this[name] = this[name] || [];\n    this[name].forEach(function (callback) {\n      callback.call(env && env.context ? env.context : env, env);\n    });\n  }\n}\n\n/**\n * @implements {IPlugins}\n */\nclass Plugins {\n  constructor(jsep) {\n    this.jsep = jsep;\n    this.registered = {};\n  }\n\n  /**\n   * @callback PluginSetup\n   * @this {Jsep} jsep\n   * @returns: void\n   */\n  /**\n   * Adds the given plugin(s) to the registry\n   *\n   * @param {object} plugins\n   * @param {string} plugins.name The name of the plugin\n   * @param {PluginSetup} plugins.init The init function\n   * @public\n   */\n  register() {\n    for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {\n      plugins[_key] = arguments[_key];\n    }\n    plugins.forEach(plugin => {\n      if (typeof plugin !== 'object' || !plugin.name || !plugin.init) {\n        throw new Error('Invalid JSEP plugin format');\n      }\n      if (this.registered[plugin.name]) {\n        // already registered. Ignore.\n        return;\n      }\n      plugin.init(this.jsep);\n      this.registered[plugin.name] = plugin;\n    });\n  }\n}\n\n//     JavaScript Expression Parser (JSEP) 1.4.0\n\nclass Jsep {\n  /**\n   * @returns {string}\n   */\n  static get version() {\n    // To be filled in by the template\n    return '1.4.0';\n  }\n\n  /**\n   * @returns {string}\n   */\n  static toString() {\n    return 'JavaScript Expression Parser (JSEP) v' + Jsep.version;\n  }\n  // ==================== CONFIG ================================\n  /**\n   * @method addUnaryOp\n   * @param {string} op_name The name of the unary op to add\n   * @returns {Jsep}\n   */\n  static addUnaryOp(op_name) {\n    Jsep.max_unop_len = Math.max(op_name.length, Jsep.max_unop_len);\n    Jsep.unary_ops[op_name] = 1;\n    return Jsep;\n  }\n\n  /**\n   * @method jsep.addBinaryOp\n   * @param {string} op_name The name of the binary op to add\n   * @param {number} precedence The precedence of the binary op (can be a float). Higher number = higher precedence\n   * @param {boolean} [isRightAssociative=false] whether operator is right-associative\n   * @returns {Jsep}\n   */\n  static addBinaryOp(op_name, precedence, isRightAssociative) {\n    Jsep.max_binop_len = Math.max(op_name.length, Jsep.max_binop_len);\n    Jsep.binary_ops[op_name] = precedence;\n    if (isRightAssociative) {\n      Jsep.right_associative.add(op_name);\n    } else {\n      Jsep.right_associative.delete(op_name);\n    }\n    return Jsep;\n  }\n\n  /**\n   * @method addIdentifierChar\n   * @param {string} char The additional character to treat as a valid part of an identifier\n   * @returns {Jsep}\n   */\n  static addIdentifierChar(char) {\n    Jsep.additional_identifier_chars.add(char);\n    return Jsep;\n  }\n\n  /**\n   * @method addLiteral\n   * @param {string} literal_name The name of the literal to add\n   * @param {*} literal_value The value of the literal\n   * @returns {Jsep}\n   */\n  static addLiteral(literal_name, literal_value) {\n    Jsep.literals[literal_name] = literal_value;\n    return Jsep;\n  }\n\n  /**\n   * @method removeUnaryOp\n   * @param {string} op_name The name of the unary op to remove\n   * @returns {Jsep}\n   */\n  static removeUnaryOp(op_name) {\n    delete Jsep.unary_ops[op_name];\n    if (op_name.length === Jsep.max_unop_len) {\n      Jsep.max_unop_len = Jsep.getMaxKeyLen(Jsep.unary_ops);\n    }\n    return Jsep;\n  }\n\n  /**\n   * @method removeAllUnaryOps\n   * @returns {Jsep}\n   */\n  static removeAllUnaryOps() {\n    Jsep.unary_ops = {};\n    Jsep.max_unop_len = 0;\n    return Jsep;\n  }\n\n  /**\n   * @method removeIdentifierChar\n   * @param {string} char The additional character to stop treating as a valid part of an identifier\n   * @returns {Jsep}\n   */\n  static removeIdentifierChar(char) {\n    Jsep.additional_identifier_chars.delete(char);\n    return Jsep;\n  }\n\n  /**\n   * @method removeBinaryOp\n   * @param {string} op_name The name of the binary op to remove\n   * @returns {Jsep}\n   */\n  static removeBinaryOp(op_name) {\n    delete Jsep.binary_ops[op_name];\n    if (op_name.length === Jsep.max_binop_len) {\n      Jsep.max_binop_len = Jsep.getMaxKeyLen(Jsep.binary_ops);\n    }\n    Jsep.right_associative.delete(op_name);\n    return Jsep;\n  }\n\n  /**\n   * @method removeAllBinaryOps\n   * @returns {Jsep}\n   */\n  static removeAllBinaryOps() {\n    Jsep.binary_ops = {};\n    Jsep.max_binop_len = 0;\n    return Jsep;\n  }\n\n  /**\n   * @method removeLiteral\n   * @param {string} literal_name The name of the literal to remove\n   * @returns {Jsep}\n   */\n  static removeLiteral(literal_name) {\n    delete Jsep.literals[literal_name];\n    return Jsep;\n  }\n\n  /**\n   * @method removeAllLiterals\n   * @returns {Jsep}\n   */\n  static removeAllLiterals() {\n    Jsep.literals = {};\n    return Jsep;\n  }\n  // ==================== END CONFIG ============================\n\n  /**\n   * @returns {string}\n   */\n  get char() {\n    return this.expr.charAt(this.index);\n  }\n\n  /**\n   * @returns {number}\n   */\n  get code() {\n    return this.expr.charCodeAt(this.index);\n  }\n  /**\n   * @param {string} expr a string with the passed in express\n   * @returns Jsep\n   */\n  constructor(expr) {\n    // `index` stores the character number we are currently at\n    // All of the gobbles below will modify `index` as we move along\n    this.expr = expr;\n    this.index = 0;\n  }\n\n  /**\n   * static top-level parser\n   * @returns {jsep.Expression}\n   */\n  static parse(expr) {\n    return new Jsep(expr).parse();\n  }\n\n  /**\n   * Get the longest key length of any object\n   * @param {object} obj\n   * @returns {number}\n   */\n  static getMaxKeyLen(obj) {\n    return Math.max(0, ...Object.keys(obj).map(k => k.length));\n  }\n\n  /**\n   * `ch` is a character code in the next three functions\n   * @param {number} ch\n   * @returns {boolean}\n   */\n  static isDecimalDigit(ch) {\n    return ch >= 48 && ch <= 57; // 0...9\n  }\n\n  /**\n   * Returns the precedence of a binary operator or `0` if it isn't a binary operator. Can be float.\n   * @param {string} op_val\n   * @returns {number}\n   */\n  static binaryPrecedence(op_val) {\n    return Jsep.binary_ops[op_val] || 0;\n  }\n\n  /**\n   * Looks for start of identifier\n   * @param {number} ch\n   * @returns {boolean}\n   */\n  static isIdentifierStart(ch) {\n    return ch >= 65 && ch <= 90 ||\n    // A...Z\n    ch >= 97 && ch <= 122 ||\n    // a...z\n    ch >= 128 && !Jsep.binary_ops[String.fromCharCode(ch)] ||\n    // any non-ASCII that is not an operator\n    Jsep.additional_identifier_chars.has(String.fromCharCode(ch)); // additional characters\n  }\n\n  /**\n   * @param {number} ch\n   * @returns {boolean}\n   */\n  static isIdentifierPart(ch) {\n    return Jsep.isIdentifierStart(ch) || Jsep.isDecimalDigit(ch);\n  }\n\n  /**\n   * throw error at index of the expression\n   * @param {string} message\n   * @throws\n   */\n  throwError(message) {\n    const error = new Error(message + ' at character ' + this.index);\n    error.index = this.index;\n    error.description = message;\n    throw error;\n  }\n\n  /**\n   * Run a given hook\n   * @param {string} name\n   * @param {jsep.Expression|false} [node]\n   * @returns {?jsep.Expression}\n   */\n  runHook(name, node) {\n    if (Jsep.hooks[name]) {\n      const env = {\n        context: this,\n        node\n      };\n      Jsep.hooks.run(name, env);\n      return env.node;\n    }\n    return node;\n  }\n\n  /**\n   * Runs a given hook until one returns a node\n   * @param {string} name\n   * @returns {?jsep.Expression}\n   */\n  searchHook(name) {\n    if (Jsep.hooks[name]) {\n      const env = {\n        context: this\n      };\n      Jsep.hooks[name].find(function (callback) {\n        callback.call(env.context, env);\n        return env.node;\n      });\n      return env.node;\n    }\n  }\n\n  /**\n   * Push `index` up to the next non-space character\n   */\n  gobbleSpaces() {\n    let ch = this.code;\n    // Whitespace\n    while (ch === Jsep.SPACE_CODE || ch === Jsep.TAB_CODE || ch === Jsep.LF_CODE || ch === Jsep.CR_CODE) {\n      ch = this.expr.charCodeAt(++this.index);\n    }\n    this.runHook('gobble-spaces');\n  }\n\n  /**\n   * Top-level method to parse all expressions and returns compound or single node\n   * @returns {jsep.Expression}\n   */\n  parse() {\n    this.runHook('before-all');\n    const nodes = this.gobbleExpressions();\n\n    // If there's only one expression just try returning the expression\n    const node = nodes.length === 1 ? nodes[0] : {\n      type: Jsep.COMPOUND,\n      body: nodes\n    };\n    return this.runHook('after-all', node);\n  }\n\n  /**\n   * top-level parser (but can be reused within as well)\n   * @param {number} [untilICode]\n   * @returns {jsep.Expression[]}\n   */\n  gobbleExpressions(untilICode) {\n    let nodes = [],\n      ch_i,\n      node;\n    while (this.index < this.expr.length) {\n      ch_i = this.code;\n\n      // Expressions can be separated by semicolons, commas, or just inferred without any\n      // separators\n      if (ch_i === Jsep.SEMCOL_CODE || ch_i === Jsep.COMMA_CODE) {\n        this.index++; // ignore separators\n      } else {\n        // Try to gobble each expression individually\n        if (node = this.gobbleExpression()) {\n          nodes.push(node);\n          // If we weren't able to find a binary expression and are out of room, then\n          // the expression passed in probably has too much\n        } else if (this.index < this.expr.length) {\n          if (ch_i === untilICode) {\n            break;\n          }\n          this.throwError('Unexpected \"' + this.char + '\"');\n        }\n      }\n    }\n    return nodes;\n  }\n\n  /**\n   * The main parsing function.\n   * @returns {?jsep.Expression}\n   */\n  gobbleExpression() {\n    const node = this.searchHook('gobble-expression') || this.gobbleBinaryExpression();\n    this.gobbleSpaces();\n    return this.runHook('after-expression', node);\n  }\n\n  /**\n   * Search for the operation portion of the string (e.g. `+`, `===`)\n   * Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)\n   * and move down from 3 to 2 to 1 character until a matching binary operation is found\n   * then, return that binary operation\n   * @returns {string|boolean}\n   */\n  gobbleBinaryOp() {\n    this.gobbleSpaces();\n    let to_check = this.expr.substr(this.index, Jsep.max_binop_len);\n    let tc_len = to_check.length;\n    while (tc_len > 0) {\n      // Don't accept a binary op when it is an identifier.\n      // Binary ops that start with a identifier-valid character must be followed\n      // by a non identifier-part valid character\n      if (Jsep.binary_ops.hasOwnProperty(to_check) && (!Jsep.isIdentifierStart(this.code) || this.index + to_check.length < this.expr.length && !Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))) {\n        this.index += tc_len;\n        return to_check;\n      }\n      to_check = to_check.substr(0, --tc_len);\n    }\n    return false;\n  }\n\n  /**\n   * This function is responsible for gobbling an individual expression,\n   * e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`\n   * @returns {?jsep.BinaryExpression}\n   */\n  gobbleBinaryExpression() {\n    let node, biop, prec, stack, biop_info, left, right, i, cur_biop;\n\n    // First, try to get the leftmost thing\n    // Then, check to see if there's a binary operator operating on that leftmost thing\n    // Don't gobbleBinaryOp without a left-hand-side\n    left = this.gobbleToken();\n    if (!left) {\n      return left;\n    }\n    biop = this.gobbleBinaryOp();\n\n    // If there wasn't a binary operator, just return the leftmost node\n    if (!biop) {\n      return left;\n    }\n\n    // Otherwise, we need to start a stack to properly place the binary operations in their\n    // precedence structure\n    biop_info = {\n      value: biop,\n      prec: Jsep.binaryPrecedence(biop),\n      right_a: Jsep.right_associative.has(biop)\n    };\n    right = this.gobbleToken();\n    if (!right) {\n      this.throwError(\"Expected expression after \" + biop);\n    }\n    stack = [left, biop_info, right];\n\n    // Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)\n    while (biop = this.gobbleBinaryOp()) {\n      prec = Jsep.binaryPrecedence(biop);\n      if (prec === 0) {\n        this.index -= biop.length;\n        break;\n      }\n      biop_info = {\n        value: biop,\n        prec,\n        right_a: Jsep.right_associative.has(biop)\n      };\n      cur_biop = biop;\n\n      // Reduce: make a binary expression from the three topmost entries.\n      const comparePrev = prev => biop_info.right_a && prev.right_a ? prec > prev.prec : prec <= prev.prec;\n      while (stack.length > 2 && comparePrev(stack[stack.length - 2])) {\n        right = stack.pop();\n        biop = stack.pop().value;\n        left = stack.pop();\n        node = {\n          type: Jsep.BINARY_EXP,\n          operator: biop,\n          left,\n          right\n        };\n        stack.push(node);\n      }\n      node = this.gobbleToken();\n      if (!node) {\n        this.throwError(\"Expected expression after \" + cur_biop);\n      }\n      stack.push(biop_info, node);\n    }\n    i = stack.length - 1;\n    node = stack[i];\n    while (i > 1) {\n      node = {\n        type: Jsep.BINARY_EXP,\n        operator: stack[i - 1].value,\n        left: stack[i - 2],\n        right: node\n      };\n      i -= 2;\n    }\n    return node;\n  }\n\n  /**\n   * An individual part of a binary expression:\n   * e.g. `foo.bar(baz)`, `1`, `\"abc\"`, `(a % 2)` (because it's in parenthesis)\n   * @returns {boolean|jsep.Expression}\n   */\n  gobbleToken() {\n    let ch, to_check, tc_len, node;\n    this.gobbleSpaces();\n    node = this.searchHook('gobble-token');\n    if (node) {\n      return this.runHook('after-token', node);\n    }\n    ch = this.code;\n    if (Jsep.isDecimalDigit(ch) || ch === Jsep.PERIOD_CODE) {\n      // Char code 46 is a dot `.` which can start off a numeric literal\n      return this.gobbleNumericLiteral();\n    }\n    if (ch === Jsep.SQUOTE_CODE || ch === Jsep.DQUOTE_CODE) {\n      // Single or double quotes\n      node = this.gobbleStringLiteral();\n    } else if (ch === Jsep.OBRACK_CODE) {\n      node = this.gobbleArray();\n    } else {\n      to_check = this.expr.substr(this.index, Jsep.max_unop_len);\n      tc_len = to_check.length;\n      while (tc_len > 0) {\n        // Don't accept an unary op when it is an identifier.\n        // Unary ops that start with a identifier-valid character must be followed\n        // by a non identifier-part valid character\n        if (Jsep.unary_ops.hasOwnProperty(to_check) && (!Jsep.isIdentifierStart(this.code) || this.index + to_check.length < this.expr.length && !Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))) {\n          this.index += tc_len;\n          const argument = this.gobbleToken();\n          if (!argument) {\n            this.throwError('missing unaryOp argument');\n          }\n          return this.runHook('after-token', {\n            type: Jsep.UNARY_EXP,\n            operator: to_check,\n            argument,\n            prefix: true\n          });\n        }\n        to_check = to_check.substr(0, --tc_len);\n      }\n      if (Jsep.isIdentifierStart(ch)) {\n        node = this.gobbleIdentifier();\n        if (Jsep.literals.hasOwnProperty(node.name)) {\n          node = {\n            type: Jsep.LITERAL,\n            value: Jsep.literals[node.name],\n            raw: node.name\n          };\n        } else if (node.name === Jsep.this_str) {\n          node = {\n            type: Jsep.THIS_EXP\n          };\n        }\n      } else if (ch === Jsep.OPAREN_CODE) {\n        // open parenthesis\n        node = this.gobbleGroup();\n      }\n    }\n    if (!node) {\n      return this.runHook('after-token', false);\n    }\n    node = this.gobbleTokenProperty(node);\n    return this.runHook('after-token', node);\n  }\n\n  /**\n   * Gobble properties of of identifiers/strings/arrays/groups.\n   * e.g. `foo`, `bar.baz`, `foo['bar'].baz`\n   * It also gobbles function calls:\n   * e.g. `Math.acos(obj.angle)`\n   * @param {jsep.Expression} node\n   * @returns {jsep.Expression}\n   */\n  gobbleTokenProperty(node) {\n    this.gobbleSpaces();\n    let ch = this.code;\n    while (ch === Jsep.PERIOD_CODE || ch === Jsep.OBRACK_CODE || ch === Jsep.OPAREN_CODE || ch === Jsep.QUMARK_CODE) {\n      let optional;\n      if (ch === Jsep.QUMARK_CODE) {\n        if (this.expr.charCodeAt(this.index + 1) !== Jsep.PERIOD_CODE) {\n          break;\n        }\n        optional = true;\n        this.index += 2;\n        this.gobbleSpaces();\n        ch = this.code;\n      }\n      this.index++;\n      if (ch === Jsep.OBRACK_CODE) {\n        node = {\n          type: Jsep.MEMBER_EXP,\n          computed: true,\n          object: node,\n          property: this.gobbleExpression()\n        };\n        if (!node.property) {\n          this.throwError('Unexpected \"' + this.char + '\"');\n        }\n        this.gobbleSpaces();\n        ch = this.code;\n        if (ch !== Jsep.CBRACK_CODE) {\n          this.throwError('Unclosed [');\n        }\n        this.index++;\n      } else if (ch === Jsep.OPAREN_CODE) {\n        // A function call is being made; gobble all the arguments\n        node = {\n          type: Jsep.CALL_EXP,\n          'arguments': this.gobbleArguments(Jsep.CPAREN_CODE),\n          callee: node\n        };\n      } else if (ch === Jsep.PERIOD_CODE || optional) {\n        if (optional) {\n          this.index--;\n        }\n        this.gobbleSpaces();\n        node = {\n          type: Jsep.MEMBER_EXP,\n          computed: false,\n          object: node,\n          property: this.gobbleIdentifier()\n        };\n      }\n      if (optional) {\n        node.optional = true;\n      } // else leave undefined for compatibility with esprima\n\n      this.gobbleSpaces();\n      ch = this.code;\n    }\n    return node;\n  }\n\n  /**\n   * Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to\n   * keep track of everything in the numeric literal and then calling `parseFloat` on that string\n   * @returns {jsep.Literal}\n   */\n  gobbleNumericLiteral() {\n    let number = '',\n      ch,\n      chCode;\n    while (Jsep.isDecimalDigit(this.code)) {\n      number += this.expr.charAt(this.index++);\n    }\n    if (this.code === Jsep.PERIOD_CODE) {\n      // can start with a decimal marker\n      number += this.expr.charAt(this.index++);\n      while (Jsep.isDecimalDigit(this.code)) {\n        number += this.expr.charAt(this.index++);\n      }\n    }\n    ch = this.char;\n    if (ch === 'e' || ch === 'E') {\n      // exponent marker\n      number += this.expr.charAt(this.index++);\n      ch = this.char;\n      if (ch === '+' || ch === '-') {\n        // exponent sign\n        number += this.expr.charAt(this.index++);\n      }\n      while (Jsep.isDecimalDigit(this.code)) {\n        // exponent itself\n        number += this.expr.charAt(this.index++);\n      }\n      if (!Jsep.isDecimalDigit(this.expr.charCodeAt(this.index - 1))) {\n        this.throwError('Expected exponent (' + number + this.char + ')');\n      }\n    }\n    chCode = this.code;\n\n    // Check to make sure this isn't a variable name that start with a number (123abc)\n    if (Jsep.isIdentifierStart(chCode)) {\n      this.throwError('Variable names cannot start with a number (' + number + this.char + ')');\n    } else if (chCode === Jsep.PERIOD_CODE || number.length === 1 && number.charCodeAt(0) === Jsep.PERIOD_CODE) {\n      this.throwError('Unexpected period');\n    }\n    return {\n      type: Jsep.LITERAL,\n      value: parseFloat(number),\n      raw: number\n    };\n  }\n\n  /**\n   * Parses a string literal, staring with single or double quotes with basic support for escape codes\n   * e.g. `\"hello world\"`, `'this is\\nJSEP'`\n   * @returns {jsep.Literal}\n   */\n  gobbleStringLiteral() {\n    let str = '';\n    const startIndex = this.index;\n    const quote = this.expr.charAt(this.index++);\n    let closed = false;\n    while (this.index < this.expr.length) {\n      let ch = this.expr.charAt(this.index++);\n      if (ch === quote) {\n        closed = true;\n        break;\n      } else if (ch === '\\\\') {\n        // Check for all of the common escape codes\n        ch = this.expr.charAt(this.index++);\n        switch (ch) {\n          case 'n':\n            str += '\\n';\n            break;\n          case 'r':\n            str += '\\r';\n            break;\n          case 't':\n            str += '\\t';\n            break;\n          case 'b':\n            str += '\\b';\n            break;\n          case 'f':\n            str += '\\f';\n            break;\n          case 'v':\n            str += '\\x0B';\n            break;\n          default:\n            str += ch;\n        }\n      } else {\n        str += ch;\n      }\n    }\n    if (!closed) {\n      this.throwError('Unclosed quote after \"' + str + '\"');\n    }\n    return {\n      type: Jsep.LITERAL,\n      value: str,\n      raw: this.expr.substring(startIndex, this.index)\n    };\n  }\n\n  /**\n   * Gobbles only identifiers\n   * e.g.: `foo`, `_value`, `$x1`\n   * Also, this function checks if that identifier is a literal:\n   * (e.g. `true`, `false`, `null`) or `this`\n   * @returns {jsep.Identifier}\n   */\n  gobbleIdentifier() {\n    let ch = this.code,\n      start = this.index;\n    if (Jsep.isIdentifierStart(ch)) {\n      this.index++;\n    } else {\n      this.throwError('Unexpected ' + this.char);\n    }\n    while (this.index < this.expr.length) {\n      ch = this.code;\n      if (Jsep.isIdentifierPart(ch)) {\n        this.index++;\n      } else {\n        break;\n      }\n    }\n    return {\n      type: Jsep.IDENTIFIER,\n      name: this.expr.slice(start, this.index)\n    };\n  }\n\n  /**\n   * Gobbles a list of arguments within the context of a function call\n   * or array literal. This function also assumes that the opening character\n   * `(` or `[` has already been gobbled, and gobbles expressions and commas\n   * until the terminator character `)` or `]` is encountered.\n   * e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`\n   * @param {number} termination\n   * @returns {jsep.Expression[]}\n   */\n  gobbleArguments(termination) {\n    const args = [];\n    let closed = false;\n    let separator_count = 0;\n    while (this.index < this.expr.length) {\n      this.gobbleSpaces();\n      let ch_i = this.code;\n      if (ch_i === termination) {\n        // done parsing\n        closed = true;\n        this.index++;\n        if (termination === Jsep.CPAREN_CODE && separator_count && separator_count >= args.length) {\n          this.throwError('Unexpected token ' + String.fromCharCode(termination));\n        }\n        break;\n      } else if (ch_i === Jsep.COMMA_CODE) {\n        // between expressions\n        this.index++;\n        separator_count++;\n        if (separator_count !== args.length) {\n          // missing argument\n          if (termination === Jsep.CPAREN_CODE) {\n            this.throwError('Unexpected token ,');\n          } else if (termination === Jsep.CBRACK_CODE) {\n            for (let arg = args.length; arg < separator_count; arg++) {\n              args.push(null);\n            }\n          }\n        }\n      } else if (args.length !== separator_count && separator_count !== 0) {\n        // NOTE: `&& separator_count !== 0` allows for either all commas, or all spaces as arguments\n        this.throwError('Expected comma');\n      } else {\n        const node = this.gobbleExpression();\n        if (!node || node.type === Jsep.COMPOUND) {\n          this.throwError('Expected comma');\n        }\n        args.push(node);\n      }\n    }\n    if (!closed) {\n      this.throwError('Expected ' + String.fromCharCode(termination));\n    }\n    return args;\n  }\n\n  /**\n   * Responsible for parsing a group of things within parentheses `()`\n   * that have no identifier in front (so not a function call)\n   * This function assumes that it needs to gobble the opening parenthesis\n   * and then tries to gobble everything within that parenthesis, assuming\n   * that the next thing it should see is the close parenthesis. If not,\n   * then the expression probably doesn't have a `)`\n   * @returns {boolean|jsep.Expression}\n   */\n  gobbleGroup() {\n    this.index++;\n    let nodes = this.gobbleExpressions(Jsep.CPAREN_CODE);\n    if (this.code === Jsep.CPAREN_CODE) {\n      this.index++;\n      if (nodes.length === 1) {\n        return nodes[0];\n      } else if (!nodes.length) {\n        return false;\n      } else {\n        return {\n          type: Jsep.SEQUENCE_EXP,\n          expressions: nodes\n        };\n      }\n    } else {\n      this.throwError('Unclosed (');\n    }\n  }\n\n  /**\n   * Responsible for parsing Array literals `[1, 2, 3]`\n   * This function assumes that it needs to gobble the opening bracket\n   * and then tries to gobble the expressions as arguments.\n   * @returns {jsep.ArrayExpression}\n   */\n  gobbleArray() {\n    this.index++;\n    return {\n      type: Jsep.ARRAY_EXP,\n      elements: this.gobbleArguments(Jsep.CBRACK_CODE)\n    };\n  }\n}\n\n// Static fields:\nconst hooks = new Hooks();\nObject.assign(Jsep, {\n  hooks,\n  plugins: new Plugins(Jsep),\n  // Node Types\n  // ----------\n  // This is the full set of types that any JSEP node can be.\n  // Store them here to save space when minified\n  COMPOUND: 'Compound',\n  SEQUENCE_EXP: 'SequenceExpression',\n  IDENTIFIER: 'Identifier',\n  MEMBER_EXP: 'MemberExpression',\n  LITERAL: 'Literal',\n  THIS_EXP: 'ThisExpression',\n  CALL_EXP: 'CallExpression',\n  UNARY_EXP: 'UnaryExpression',\n  BINARY_EXP: 'BinaryExpression',\n  ARRAY_EXP: 'ArrayExpression',\n  TAB_CODE: 9,\n  LF_CODE: 10,\n  CR_CODE: 13,\n  SPACE_CODE: 32,\n  PERIOD_CODE: 46,\n  // '.'\n  COMMA_CODE: 44,\n  // ','\n  SQUOTE_CODE: 39,\n  // single quote\n  DQUOTE_CODE: 34,\n  // double quotes\n  OPAREN_CODE: 40,\n  // (\n  CPAREN_CODE: 41,\n  // )\n  OBRACK_CODE: 91,\n  // [\n  CBRACK_CODE: 93,\n  // ]\n  QUMARK_CODE: 63,\n  // ?\n  SEMCOL_CODE: 59,\n  // ;\n  COLON_CODE: 58,\n  // :\n\n  // Operations\n  // ----------\n  // Use a quickly-accessible map to store all of the unary operators\n  // Values are set to `1` (it really doesn't matter)\n  unary_ops: {\n    '-': 1,\n    '!': 1,\n    '~': 1,\n    '+': 1\n  },\n  // Also use a map for the binary operations but set their values to their\n  // binary precedence for quick reference (higher number = higher precedence)\n  // see [Order of operations](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)\n  binary_ops: {\n    '||': 1,\n    '??': 1,\n    '&&': 2,\n    '|': 3,\n    '^': 4,\n    '&': 5,\n    '==': 6,\n    '!=': 6,\n    '===': 6,\n    '!==': 6,\n    '<': 7,\n    '>': 7,\n    '<=': 7,\n    '>=': 7,\n    '<<': 8,\n    '>>': 8,\n    '>>>': 8,\n    '+': 9,\n    '-': 9,\n    '*': 10,\n    '/': 10,\n    '%': 10,\n    '**': 11\n  },\n  // sets specific binary_ops as right-associative\n  right_associative: new Set(['**']),\n  // Additional valid identifier chars, apart from a-z, A-Z and 0-9 (except on the starting char)\n  additional_identifier_chars: new Set(['$', '_']),\n  // Literals\n  // ----------\n  // Store the values to return for the various literals we may encounter\n  literals: {\n    'true': true,\n    'false': false,\n    'null': null\n  },\n  // Except for `this`, which is special. This could be changed to something like `'self'` as well\n  this_str: 'this'\n});\nJsep.max_unop_len = Jsep.getMaxKeyLen(Jsep.unary_ops);\nJsep.max_binop_len = Jsep.getMaxKeyLen(Jsep.binary_ops);\n\n// Backward Compatibility:\nconst jsep = expr => new Jsep(expr).parse();\nconst stdClassProps = Object.getOwnPropertyNames(class Test {});\nObject.getOwnPropertyNames(Jsep).filter(prop => !stdClassProps.includes(prop) && jsep[prop] === undefined).forEach(m => {\n  jsep[m] = Jsep[m];\n});\njsep.Jsep = Jsep; // allows for const { Jsep } = require('jsep');\n\nconst CONDITIONAL_EXP = 'ConditionalExpression';\nvar ternary = {\n  name: 'ternary',\n  init(jsep) {\n    // Ternary expression: test ? consequent : alternate\n    jsep.hooks.add('after-expression', function gobbleTernary(env) {\n      if (env.node && this.code === jsep.QUMARK_CODE) {\n        this.index++;\n        const test = env.node;\n        const consequent = this.gobbleExpression();\n        if (!consequent) {\n          this.throwError('Expected expression');\n        }\n        this.gobbleSpaces();\n        if (this.code === jsep.COLON_CODE) {\n          this.index++;\n          const alternate = this.gobbleExpression();\n          if (!alternate) {\n            this.throwError('Expected expression');\n          }\n          env.node = {\n            type: CONDITIONAL_EXP,\n            test,\n            consequent,\n            alternate\n          };\n\n          // check for operators of higher priority than ternary (i.e. assignment)\n          // jsep sets || at 1, and assignment at 0.9, and conditional should be between them\n          if (test.operator && jsep.binary_ops[test.operator] <= 0.9) {\n            let newTest = test;\n            while (newTest.right.operator && jsep.binary_ops[newTest.right.operator] <= 0.9) {\n              newTest = newTest.right;\n            }\n            env.node.test = newTest.right;\n            newTest.right = env.node;\n            env.node = test;\n          }\n        } else {\n          this.throwError('Expected :');\n        }\n      }\n    });\n  }\n};\n\n// Add default plugins:\n\njsep.plugins.register(ternary);\nconst FSLASH_CODE = 47; // '/'\nconst BSLASH_CODE = 92; // '\\\\'\n\nvar index = {\n  name: 'regex',\n  init(jsep) {\n    // Regex literal: /abc123/ig\n    jsep.hooks.add('gobble-token', function gobbleRegexLiteral(env) {\n      if (this.code === FSLASH_CODE) {\n        const patternIndex = ++this.index;\n        let inCharSet = false;\n        while (this.index < this.expr.length) {\n          if (this.code === FSLASH_CODE && !inCharSet) {\n            const pattern = this.expr.slice(patternIndex, this.index);\n            let flags = '';\n            while (++this.index < this.expr.length) {\n              const code = this.code;\n              if (code >= 97 && code <= 122 // a...z\n              || code >= 65 && code <= 90 // A...Z\n              || code >= 48 && code <= 57) {\n                // 0-9\n                flags += this.char;\n              } else {\n                break;\n              }\n            }\n            let value;\n            try {\n              value = new RegExp(pattern, flags);\n            } catch (e) {\n              this.throwError(e.message);\n            }\n            env.node = {\n              type: jsep.LITERAL,\n              value,\n              raw: this.expr.slice(patternIndex - 1, this.index)\n            };\n\n            // allow . [] and () after regex: /regex/.test(a)\n            env.node = this.gobbleTokenProperty(env.node);\n            return env.node;\n          }\n          if (this.code === jsep.OBRACK_CODE) {\n            inCharSet = true;\n          } else if (inCharSet && this.code === jsep.CBRACK_CODE) {\n            inCharSet = false;\n          }\n          this.index += this.code === BSLASH_CODE ? 2 : 1;\n        }\n        this.throwError('Unclosed Regex');\n      }\n    });\n  }\n};\nconst PLUS_CODE = 43; // +\nconst MINUS_CODE = 45; // -\n\nconst plugin = {\n  name: 'assignment',\n  assignmentOperators: new Set(['=', '*=', '**=', '/=', '%=', '+=', '-=', '<<=', '>>=', '>>>=', '&=', '^=', '|=', '||=', '&&=', '??=']),\n  updateOperators: [PLUS_CODE, MINUS_CODE],\n  assignmentPrecedence: 0.9,\n  init(jsep) {\n    const updateNodeTypes = [jsep.IDENTIFIER, jsep.MEMBER_EXP];\n    plugin.assignmentOperators.forEach(op => jsep.addBinaryOp(op, plugin.assignmentPrecedence, true));\n    jsep.hooks.add('gobble-token', function gobbleUpdatePrefix(env) {\n      const code = this.code;\n      if (plugin.updateOperators.some(c => c === code && c === this.expr.charCodeAt(this.index + 1))) {\n        this.index += 2;\n        env.node = {\n          type: 'UpdateExpression',\n          operator: code === PLUS_CODE ? '++' : '--',\n          argument: this.gobbleTokenProperty(this.gobbleIdentifier()),\n          prefix: true\n        };\n        if (!env.node.argument || !updateNodeTypes.includes(env.node.argument.type)) {\n          this.throwError(`Unexpected ${env.node.operator}`);\n        }\n      }\n    });\n    jsep.hooks.add('after-token', function gobbleUpdatePostfix(env) {\n      if (env.node) {\n        const code = this.code;\n        if (plugin.updateOperators.some(c => c === code && c === this.expr.charCodeAt(this.index + 1))) {\n          if (!updateNodeTypes.includes(env.node.type)) {\n            this.throwError(`Unexpected ${env.node.operator}`);\n          }\n          this.index += 2;\n          env.node = {\n            type: 'UpdateExpression',\n            operator: code === PLUS_CODE ? '++' : '--',\n            argument: env.node,\n            prefix: false\n          };\n        }\n      }\n    });\n    jsep.hooks.add('after-expression', function gobbleAssignment(env) {\n      if (env.node) {\n        // Note: Binaries can be chained in a single expression to respect\n        // operator precedence (i.e. a = b = 1 + 2 + 3)\n        // Update all binary assignment nodes in the tree\n        updateBinariesToAssignments(env.node);\n      }\n    });\n    function updateBinariesToAssignments(node) {\n      if (plugin.assignmentOperators.has(node.operator)) {\n        node.type = 'AssignmentExpression';\n        updateBinariesToAssignments(node.left);\n        updateBinariesToAssignments(node.right);\n      } else if (!node.operator) {\n        Object.values(node).forEach(val => {\n          if (val && typeof val === 'object') {\n            updateBinariesToAssignments(val);\n          }\n        });\n      }\n    }\n  }\n};\n\n/* eslint-disable no-bitwise -- Convenient */\n\n// register plugins\njsep.plugins.register(index, plugin);\njsep.addUnaryOp('typeof');\njsep.addLiteral('null', null);\njsep.addLiteral('undefined', undefined);\nconst BLOCKED_PROTO_PROPERTIES = new Set(['constructor', '__proto__', '__defineGetter__', '__defineSetter__']);\nconst SafeEval = {\n  /**\n   * @param {jsep.Expression} ast\n   * @param {Record<string, any>} subs\n   */\n  evalAst(ast, subs) {\n    switch (ast.type) {\n      case 'BinaryExpression':\n      case 'LogicalExpression':\n        return SafeEval.evalBinaryExpression(ast, subs);\n      case 'Compound':\n        return SafeEval.evalCompound(ast, subs);\n      case 'ConditionalExpression':\n        return SafeEval.evalConditionalExpression(ast, subs);\n      case 'Identifier':\n        return SafeEval.evalIdentifier(ast, subs);\n      case 'Literal':\n        return SafeEval.evalLiteral(ast, subs);\n      case 'MemberExpression':\n        return SafeEval.evalMemberExpression(ast, subs);\n      case 'UnaryExpression':\n        return SafeEval.evalUnaryExpression(ast, subs);\n      case 'ArrayExpression':\n        return SafeEval.evalArrayExpression(ast, subs);\n      case 'CallExpression':\n        return SafeEval.evalCallExpression(ast, subs);\n      case 'AssignmentExpression':\n        return SafeEval.evalAssignmentExpression(ast, subs);\n      default:\n        throw SyntaxError('Unexpected expression', ast);\n    }\n  },\n  evalBinaryExpression(ast, subs) {\n    const result = {\n      '||': (a, b) => a || b(),\n      '&&': (a, b) => a && b(),\n      '|': (a, b) => a | b(),\n      '^': (a, b) => a ^ b(),\n      '&': (a, b) => a & b(),\n      // eslint-disable-next-line eqeqeq -- API\n      '==': (a, b) => a == b(),\n      // eslint-disable-next-line eqeqeq -- API\n      '!=': (a, b) => a != b(),\n      '===': (a, b) => a === b(),\n      '!==': (a, b) => a !== b(),\n      '<': (a, b) => a < b(),\n      '>': (a, b) => a > b(),\n      '<=': (a, b) => a <= b(),\n      '>=': (a, b) => a >= b(),\n      '<<': (a, b) => a << b(),\n      '>>': (a, b) => a >> b(),\n      '>>>': (a, b) => a >>> b(),\n      '+': (a, b) => a + b(),\n      '-': (a, b) => a - b(),\n      '*': (a, b) => a * b(),\n      '/': (a, b) => a / b(),\n      '%': (a, b) => a % b()\n    }[ast.operator](SafeEval.evalAst(ast.left, subs), () => SafeEval.evalAst(ast.right, subs));\n    return result;\n  },\n  evalCompound(ast, subs) {\n    let last;\n    for (let i = 0; i < ast.body.length; i++) {\n      if (ast.body[i].type === 'Identifier' && ['var', 'let', 'const'].includes(ast.body[i].name) && ast.body[i + 1] && ast.body[i + 1].type === 'AssignmentExpression') {\n        // var x=2; is detected as\n        // [{Identifier var}, {AssignmentExpression x=2}]\n        // eslint-disable-next-line @stylistic/max-len -- Long\n        // eslint-disable-next-line sonarjs/updated-loop-counter -- Convenient\n        i += 1;\n      }\n      const expr = ast.body[i];\n      last = SafeEval.evalAst(expr, subs);\n    }\n    return last;\n  },\n  evalConditionalExpression(ast, subs) {\n    if (SafeEval.evalAst(ast.test, subs)) {\n      return SafeEval.evalAst(ast.consequent, subs);\n    }\n    return SafeEval.evalAst(ast.alternate, subs);\n  },\n  evalIdentifier(ast, subs) {\n    if (Object.hasOwn(subs, ast.name)) {\n      return subs[ast.name];\n    }\n    throw ReferenceError(`${ast.name} is not defined`);\n  },\n  evalLiteral(ast) {\n    return ast.value;\n  },\n  evalMemberExpression(ast, subs) {\n    const prop = String(\n    // NOTE: `String(value)` throws error when\n    // value has overwritten the toString method to return non-string\n    // i.e. `value = {toString: () => []}`\n    ast.computed ? SafeEval.evalAst(ast.property) // `object[property]`\n    : ast.property.name // `object.property` property is Identifier\n    );\n    const obj = SafeEval.evalAst(ast.object, subs);\n    if (obj === undefined || obj === null) {\n      throw TypeError(`Cannot read properties of ${obj} (reading '${prop}')`);\n    }\n    if (!Object.hasOwn(obj, prop) && BLOCKED_PROTO_PROPERTIES.has(prop)) {\n      throw TypeError(`Cannot read properties of ${obj} (reading '${prop}')`);\n    }\n    const result = obj[prop];\n    if (typeof result === 'function') {\n      return result.bind(obj); // arrow functions aren't affected by bind.\n    }\n    return result;\n  },\n  evalUnaryExpression(ast, subs) {\n    const result = {\n      '-': a => -SafeEval.evalAst(a, subs),\n      '!': a => !SafeEval.evalAst(a, subs),\n      '~': a => ~SafeEval.evalAst(a, subs),\n      // eslint-disable-next-line no-implicit-coercion -- API\n      '+': a => +SafeEval.evalAst(a, subs),\n      typeof: a => typeof SafeEval.evalAst(a, subs)\n    }[ast.operator](ast.argument);\n    return result;\n  },\n  evalArrayExpression(ast, subs) {\n    return ast.elements.map(el => SafeEval.evalAst(el, subs));\n  },\n  evalCallExpression(ast, subs) {\n    const args = ast.arguments.map(arg => SafeEval.evalAst(arg, subs));\n    const func = SafeEval.evalAst(ast.callee, subs);\n    // if (func === Function) {\n    //     throw new Error('Function constructor is disabled');\n    // }\n    return func(...args);\n  },\n  evalAssignmentExpression(ast, subs) {\n    if (ast.left.type !== 'Identifier') {\n      throw SyntaxError('Invalid left-hand side in assignment');\n    }\n    const id = ast.left.name;\n    const value = SafeEval.evalAst(ast.right, subs);\n    subs[id] = value;\n    return subs[id];\n  }\n};\n\n/**\n * A replacement for NodeJS' VM.Script which is also {@link https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP | Content Security Policy} friendly.\n */\nclass SafeScript {\n  /**\n   * @param {string} expr Expression to evaluate\n   */\n  constructor(expr) {\n    this.code = expr;\n    this.ast = jsep(this.code);\n  }\n\n  /**\n   * @param {object} context Object whose items will be added\n   *   to evaluation\n   * @returns {EvaluatedResult} Result of evaluated code\n   */\n  runInNewContext(context) {\n    // `Object.create(null)` creates a prototypeless object\n    const keyMap = Object.assign(Object.create(null), context);\n    return SafeEval.evalAst(this.ast, keyMap);\n  }\n}\n\n/* eslint-disable camelcase -- Convenient for escaping */\n\n/**\n * @typedef {null|boolean|number|string|object|GenericArray} JSONObject\n */\n\n/**\n * @typedef {any} AnyItem\n */\n\n/**\n * @typedef {any} AnyResult\n */\n\n/**\n * Copies array and then pushes item into it.\n * @param {GenericArray} arr Array to copy and into which to push\n * @param {AnyItem} item Array item to add (to end)\n * @returns {GenericArray} Copy of the original array\n */\nfunction push(arr, item) {\n  arr = arr.slice();\n  arr.push(item);\n  return arr;\n}\n/**\n * Copies array and then unshifts item into it.\n * @param {AnyItem} item Array item to add (to beginning)\n * @param {GenericArray} arr Array to copy and into which to unshift\n * @returns {GenericArray} Copy of the original array\n */\nfunction unshift(item, arr) {\n  arr = arr.slice();\n  arr.unshift(item);\n  return arr;\n}\n\n/**\n * Caught when JSONPath is used without `new` but rethrown if with `new`\n * @extends Error\n */\nclass NewError extends Error {\n  /**\n   * @param {AnyResult} value The evaluated scalar value\n   */\n  constructor(value) {\n    super('JSONPath should not be called with \"new\" (it prevents return ' + 'of (unwrapped) scalar values)');\n    this.avoidNew = true;\n    this.value = value;\n    this.name = 'NewError';\n  }\n}\n\n/**\n* @typedef {object} ReturnObject\n* @property {string} path\n* @property {JSONObject} value\n* @property {object|GenericArray} parent\n* @property {string} parentProperty\n*/\n\n/**\n* @callback JSONPathCallback\n* @param {string|object} preferredOutput\n* @param {\"value\"|\"property\"} type\n* @param {ReturnObject} fullRetObj\n* @returns {void}\n*/\n\n/**\n* @callback OtherTypeCallback\n* @param {JSONObject} val\n* @param {string} path\n* @param {object|GenericArray} parent\n* @param {string} parentPropName\n* @returns {boolean}\n*/\n\n/**\n * @typedef {any} ContextItem\n */\n\n/**\n * @typedef {any} EvaluatedResult\n */\n\n/**\n* @callback EvalCallback\n* @param {string} code\n* @param {ContextItem} context\n* @returns {EvaluatedResult}\n*/\n\n/**\n * @typedef {typeof SafeScript} EvalClass\n */\n\n/**\n * @typedef {object} JSONPathOptions\n * @property {JSON} json\n * @property {string|string[]} path\n * @property {\"value\"|\"path\"|\"pointer\"|\"parent\"|\"parentProperty\"|\n *   \"all\"} [resultType=\"value\"]\n * @property {boolean} [flatten=false]\n * @property {boolean} [wrap=true]\n * @property {object} [sandbox={}]\n * @property {EvalCallback|EvalClass|'safe'|'native'|\n *   boolean} [eval = 'safe']\n * @property {object|GenericArray|null} [parent=null]\n * @property {string|null} [parentProperty=null]\n * @property {JSONPathCallback} [callback]\n * @property {OtherTypeCallback} [otherTypeCallback] Defaults to\n *   function which throws on encountering `@other`\n * @property {boolean} [autostart=true]\n */\n\n/**\n * @param {string|JSONPathOptions} opts If a string, will be treated as `expr`\n * @param {string} [expr] JSON path to evaluate\n * @param {JSON} [obj] JSON object to evaluate against\n * @param {JSONPathCallback} [callback] Passed 3 arguments: 1) desired payload\n *     per `resultType`, 2) `\"value\"|\"property\"`, 3) Full returned object with\n *     all payloads\n * @param {OtherTypeCallback} [otherTypeCallback] If `@other()` is at the end\n *   of one's query, this will be invoked with the value of the item, its\n *   path, its parent, and its parent's property name, and it should return\n *   a boolean indicating whether the supplied value belongs to the \"other\"\n *   type or not (or it may handle transformations and return `false`).\n * @returns {JSONPath}\n * @class\n */\nfunction JSONPath(opts, expr, obj, callback, otherTypeCallback) {\n  // eslint-disable-next-line no-restricted-syntax -- Allow for pseudo-class\n  if (!(this instanceof JSONPath)) {\n    try {\n      return new JSONPath(opts, expr, obj, callback, otherTypeCallback);\n    } catch (e) {\n      if (!e.avoidNew) {\n        throw e;\n      }\n      return e.value;\n    }\n  }\n  if (typeof opts === 'string') {\n    otherTypeCallback = callback;\n    callback = obj;\n    obj = expr;\n    expr = opts;\n    opts = null;\n  }\n  const optObj = opts && typeof opts === 'object';\n  opts = opts || {};\n  this.json = opts.json || obj;\n  this.path = opts.path || expr;\n  this.resultType = opts.resultType || 'value';\n  this.flatten = opts.flatten || false;\n  this.wrap = Object.hasOwn(opts, 'wrap') ? opts.wrap : true;\n  this.sandbox = opts.sandbox || {};\n  this.eval = opts.eval === undefined ? 'safe' : opts.eval;\n  this.ignoreEvalErrors = typeof opts.ignoreEvalErrors === 'undefined' ? false : opts.ignoreEvalErrors;\n  this.parent = opts.parent || null;\n  this.parentProperty = opts.parentProperty || null;\n  this.callback = opts.callback || callback || null;\n  this.otherTypeCallback = opts.otherTypeCallback || otherTypeCallback || function () {\n    throw new TypeError('You must supply an otherTypeCallback callback option ' + 'with the @other() operator.');\n  };\n  if (opts.autostart !== false) {\n    const args = {\n      path: optObj ? opts.path : expr\n    };\n    if (!optObj) {\n      args.json = obj;\n    } else if ('json' in opts) {\n      args.json = opts.json;\n    }\n    const ret = this.evaluate(args);\n    if (!ret || typeof ret !== 'object') {\n      throw new NewError(ret);\n    }\n    return ret;\n  }\n}\n\n// PUBLIC METHODS\nJSONPath.prototype.evaluate = function (expr, json, callback, otherTypeCallback) {\n  let currParent = this.parent,\n    currParentProperty = this.parentProperty;\n  let {\n    flatten,\n    wrap\n  } = this;\n  this.currResultType = this.resultType;\n  this.currEval = this.eval;\n  this.currSandbox = this.sandbox;\n  callback = callback || this.callback;\n  this.currOtherTypeCallback = otherTypeCallback || this.otherTypeCallback;\n  json = json || this.json;\n  expr = expr || this.path;\n  if (expr && typeof expr === 'object' && !Array.isArray(expr)) {\n    if (!expr.path && expr.path !== '') {\n      throw new TypeError('You must supply a \"path\" property when providing an object ' + 'argument to JSONPath.evaluate().');\n    }\n    if (!Object.hasOwn(expr, 'json')) {\n      throw new TypeError('You must supply a \"json\" property when providing an object ' + 'argument to JSONPath.evaluate().');\n    }\n    ({\n      json\n    } = expr);\n    flatten = Object.hasOwn(expr, 'flatten') ? expr.flatten : flatten;\n    this.currResultType = Object.hasOwn(expr, 'resultType') ? expr.resultType : this.currResultType;\n    this.currSandbox = Object.hasOwn(expr, 'sandbox') ? expr.sandbox : this.currSandbox;\n    wrap = Object.hasOwn(expr, 'wrap') ? expr.wrap : wrap;\n    this.currEval = Object.hasOwn(expr, 'eval') ? expr.eval : this.currEval;\n    callback = Object.hasOwn(expr, 'callback') ? expr.callback : callback;\n    this.currOtherTypeCallback = Object.hasOwn(expr, 'otherTypeCallback') ? expr.otherTypeCallback : this.currOtherTypeCallback;\n    currParent = Object.hasOwn(expr, 'parent') ? expr.parent : currParent;\n    currParentProperty = Object.hasOwn(expr, 'parentProperty') ? expr.parentProperty : currParentProperty;\n    expr = expr.path;\n  }\n  currParent = currParent || null;\n  currParentProperty = currParentProperty || null;\n  if (Array.isArray(expr)) {\n    expr = JSONPath.toPathString(expr);\n  }\n  if (!expr && expr !== '' || !json) {\n    return undefined;\n  }\n  const exprList = JSONPath.toPathArray(expr);\n  if (exprList[0] === '$' && exprList.length > 1) {\n    exprList.shift();\n  }\n  this._hasParentSelector = null;\n  const result = this._trace(exprList, json, ['$'], currParent, currParentProperty, callback).filter(function (ea) {\n    return ea && !ea.isParentSelector;\n  });\n  if (!result.length) {\n    return wrap ? [] : undefined;\n  }\n  if (!wrap && result.length === 1 && !result[0].hasArrExpr) {\n    return this._getPreferredOutput(result[0]);\n  }\n  return result.reduce((rslt, ea) => {\n    const valOrPath = this._getPreferredOutput(ea);\n    if (flatten && Array.isArray(valOrPath)) {\n      rslt = rslt.concat(valOrPath);\n    } else {\n      rslt.push(valOrPath);\n    }\n    return rslt;\n  }, []);\n};\n\n// PRIVATE METHODS\n\nJSONPath.prototype._getPreferredOutput = function (ea) {\n  const resultType = this.currResultType;\n  switch (resultType) {\n    case 'all':\n      {\n        const path = Array.isArray(ea.path) ? ea.path : JSONPath.toPathArray(ea.path);\n        ea.pointer = JSONPath.toPointer(path);\n        ea.path = typeof ea.path === 'string' ? ea.path : JSONPath.toPathString(ea.path);\n        return ea;\n      }\n    case 'value':\n    case 'parent':\n    case 'parentProperty':\n      return ea[resultType];\n    case 'path':\n      return JSONPath.toPathString(ea[resultType]);\n    case 'pointer':\n      return JSONPath.toPointer(ea.path);\n    default:\n      throw new TypeError('Unknown result type');\n  }\n};\nJSONPath.prototype._handleCallback = function (fullRetObj, callback, type) {\n  if (callback) {\n    const preferredOutput = this._getPreferredOutput(fullRetObj);\n    fullRetObj.path = typeof fullRetObj.path === 'string' ? fullRetObj.path : JSONPath.toPathString(fullRetObj.path);\n    // eslint-disable-next-line n/callback-return -- No need to return\n    callback(preferredOutput, type, fullRetObj);\n  }\n};\n\n/**\n *\n * @param {string} expr\n * @param {JSONObject} val\n * @param {string} path\n * @param {object|GenericArray} parent\n * @param {string} parentPropName\n * @param {JSONPathCallback} callback\n * @param {boolean} hasArrExpr\n * @param {boolean} literalPriority\n * @returns {ReturnObject|ReturnObject[]}\n */\nJSONPath.prototype._trace = function (expr, val, path, parent, parentPropName, callback, hasArrExpr, literalPriority) {\n  // No expr to follow? return path and value as the result of\n  //  this trace branch\n  let retObj;\n  if (!expr.length) {\n    retObj = {\n      path,\n      value: val,\n      parent,\n      parentProperty: parentPropName,\n      hasArrExpr\n    };\n    this._handleCallback(retObj, callback, 'value');\n    return retObj;\n  }\n  const loc = expr[0],\n    x = expr.slice(1);\n\n  // We need to gather the return value of recursive trace calls in order to\n  // do the parent sel computation.\n  const ret = [];\n  /**\n   *\n   * @param {ReturnObject|ReturnObject[]} elems\n   * @returns {void}\n   */\n  function addRet(elems) {\n    if (Array.isArray(elems)) {\n      // This was causing excessive stack size in Node (with or\n      //  without Babel) against our performance test:\n      //  `ret.push(...elems);`\n      elems.forEach(t => {\n        ret.push(t);\n      });\n    } else {\n      ret.push(elems);\n    }\n  }\n  if ((typeof loc !== 'string' || literalPriority) && val && Object.hasOwn(val, loc)) {\n    // simple case--directly follow property\n    addRet(this._trace(x, val[loc], push(path, loc), val, loc, callback, hasArrExpr));\n    // eslint-disable-next-line unicorn/prefer-switch -- Part of larger `if`\n  } else if (loc === '*') {\n    // all child properties\n    this._walk(val, m => {\n      addRet(this._trace(x, val[m], push(path, m), val, m, callback, true, true));\n    });\n  } else if (loc === '..') {\n    // all descendent parent properties\n    // Check remaining expression with val's immediate children\n    addRet(this._trace(x, val, path, parent, parentPropName, callback, hasArrExpr));\n    this._walk(val, m => {\n      // We don't join m and x here because we only want parents,\n      //   not scalar values\n      if (typeof val[m] === 'object') {\n        // Keep going with recursive descent on val's\n        //   object children\n        addRet(this._trace(expr.slice(), val[m], push(path, m), val, m, callback, true));\n      }\n    });\n    // The parent sel computation is handled in the frame above using the\n    // ancestor object of val\n  } else if (loc === '^') {\n    // This is not a final endpoint, so we do not invoke the callback here\n    this._hasParentSelector = true;\n    return {\n      path: path.slice(0, -1),\n      expr: x,\n      isParentSelector: true\n    };\n  } else if (loc === '~') {\n    // property name\n    retObj = {\n      path: push(path, loc),\n      value: parentPropName,\n      parent,\n      parentProperty: null\n    };\n    this._handleCallback(retObj, callback, 'property');\n    return retObj;\n  } else if (loc === '$') {\n    // root only\n    addRet(this._trace(x, val, path, null, null, callback, hasArrExpr));\n  } else if (/^(-?\\d*):(-?\\d*):?(\\d*)$/u.test(loc)) {\n    // [start:end:step]  Python slice syntax\n    addRet(this._slice(loc, x, val, path, parent, parentPropName, callback));\n  } else if (loc.indexOf('?(') === 0) {\n    // [?(expr)] (filtering)\n    if (this.currEval === false) {\n      throw new Error('Eval [?(expr)] prevented in JSONPath expression.');\n    }\n    const safeLoc = loc.replace(/^\\?\\((.*?)\\)$/u, '$1');\n    // check for a nested filter expression\n    const nested = /@.?([^?]*)[['](\\??\\(.*?\\))(?!.\\)\\])[\\]']/gu.exec(safeLoc);\n    if (nested) {\n      // find if there are matches in the nested expression\n      // add them to the result set if there is at least one match\n      this._walk(val, m => {\n        const npath = [nested[2]];\n        const nvalue = nested[1] ? val[m][nested[1]] : val[m];\n        const filterResults = this._trace(npath, nvalue, path, parent, parentPropName, callback, true);\n        if (filterResults.length > 0) {\n          addRet(this._trace(x, val[m], push(path, m), val, m, callback, true));\n        }\n      });\n    } else {\n      this._walk(val, m => {\n        if (this._eval(safeLoc, val[m], m, path, parent, parentPropName)) {\n          addRet(this._trace(x, val[m], push(path, m), val, m, callback, true));\n        }\n      });\n    }\n  } else if (loc[0] === '(') {\n    // [(expr)] (dynamic property/index)\n    if (this.currEval === false) {\n      throw new Error('Eval [(expr)] prevented in JSONPath expression.');\n    }\n    // As this will resolve to a property name (but we don't know it\n    //  yet), property and parent information is relative to the\n    //  parent of the property to which this expression will resolve\n    addRet(this._trace(unshift(this._eval(loc, val, path.at(-1), path.slice(0, -1), parent, parentPropName), x), val, path, parent, parentPropName, callback, hasArrExpr));\n  } else if (loc[0] === '@') {\n    // value type: @boolean(), etc.\n    let addType = false;\n    const valueType = loc.slice(1, -2);\n    switch (valueType) {\n      case 'scalar':\n        if (!val || !['object', 'function'].includes(typeof val)) {\n          addType = true;\n        }\n        break;\n      case 'boolean':\n      case 'string':\n      case 'undefined':\n      case 'function':\n        if (typeof val === valueType) {\n          addType = true;\n        }\n        break;\n      case 'integer':\n        if (Number.isFinite(val) && !(val % 1)) {\n          addType = true;\n        }\n        break;\n      case 'number':\n        if (Number.isFinite(val)) {\n          addType = true;\n        }\n        break;\n      case 'nonFinite':\n        if (typeof val === 'number' && !Number.isFinite(val)) {\n          addType = true;\n        }\n        break;\n      case 'object':\n        if (val && typeof val === valueType) {\n          addType = true;\n        }\n        break;\n      case 'array':\n        if (Array.isArray(val)) {\n          addType = true;\n        }\n        break;\n      case 'other':\n        addType = this.currOtherTypeCallback(val, path, parent, parentPropName);\n        break;\n      case 'null':\n        if (val === null) {\n          addType = true;\n        }\n        break;\n      /* c8 ignore next 2 */\n      default:\n        throw new TypeError('Unknown value type ' + valueType);\n    }\n    if (addType) {\n      retObj = {\n        path,\n        value: val,\n        parent,\n        parentProperty: parentPropName\n      };\n      this._handleCallback(retObj, callback, 'value');\n      return retObj;\n    }\n    // `-escaped property\n  } else if (loc[0] === '`' && val && Object.hasOwn(val, loc.slice(1))) {\n    const locProp = loc.slice(1);\n    addRet(this._trace(x, val[locProp], push(path, locProp), val, locProp, callback, hasArrExpr, true));\n  } else if (loc.includes(',')) {\n    // [name1,name2,...]\n    const parts = loc.split(',');\n    for (const part of parts) {\n      addRet(this._trace(unshift(part, x), val, path, parent, parentPropName, callback, true));\n    }\n    // simple case--directly follow property\n  } else if (!literalPriority && val && Object.hasOwn(val, loc)) {\n    addRet(this._trace(x, val[loc], push(path, loc), val, loc, callback, hasArrExpr, true));\n  }\n\n  // We check the resulting values for parent selections. For parent\n  // selections we discard the value object and continue the trace with the\n  // current val object\n  if (this._hasParentSelector) {\n    for (let t = 0; t < ret.length; t++) {\n      const rett = ret[t];\n      if (rett && rett.isParentSelector) {\n        const tmp = this._trace(rett.expr, val, rett.path, parent, parentPropName, callback, hasArrExpr);\n        if (Array.isArray(tmp)) {\n          ret[t] = tmp[0];\n          const tl = tmp.length;\n          for (let tt = 1; tt < tl; tt++) {\n            // eslint-disable-next-line @stylistic/max-len -- Long\n            // eslint-disable-next-line sonarjs/updated-loop-counter -- Convenient\n            t++;\n            ret.splice(t, 0, tmp[tt]);\n          }\n        } else {\n          ret[t] = tmp;\n        }\n      }\n    }\n  }\n  return ret;\n};\nJSONPath.prototype._walk = function (val, f) {\n  if (Array.isArray(val)) {\n    const n = val.length;\n    for (let i = 0; i < n; i++) {\n      f(i);\n    }\n  } else if (val && typeof val === 'object') {\n    Object.keys(val).forEach(m => {\n      f(m);\n    });\n  }\n};\nJSONPath.prototype._slice = function (loc, expr, val, path, parent, parentPropName, callback) {\n  if (!Array.isArray(val)) {\n    return undefined;\n  }\n  const len = val.length,\n    parts = loc.split(':'),\n    step = parts[2] && Number.parseInt(parts[2]) || 1;\n  let start = parts[0] && Number.parseInt(parts[0]) || 0,\n    end = parts[1] && Number.parseInt(parts[1]) || len;\n  start = start < 0 ? Math.max(0, start + len) : Math.min(len, start);\n  end = end < 0 ? Math.max(0, end + len) : Math.min(len, end);\n  const ret = [];\n  for (let i = start; i < end; i += step) {\n    const tmp = this._trace(unshift(i, expr), val, path, parent, parentPropName, callback, true);\n    // Should only be possible to be an array here since first part of\n    //   ``unshift(i, expr)` passed in above would not be empty, nor `~`,\n    //     nor begin with `@` (as could return objects)\n    // This was causing excessive stack size in Node (with or\n    //  without Babel) against our performance test: `ret.push(...tmp);`\n    tmp.forEach(t => {\n      ret.push(t);\n    });\n  }\n  return ret;\n};\nJSONPath.prototype._eval = function (code, _v, _vname, path, parent, parentPropName) {\n  this.currSandbox._$_parentProperty = parentPropName;\n  this.currSandbox._$_parent = parent;\n  this.currSandbox._$_property = _vname;\n  this.currSandbox._$_root = this.json;\n  this.currSandbox._$_v = _v;\n  const containsPath = code.includes('@path');\n  if (containsPath) {\n    this.currSandbox._$_path = JSONPath.toPathString(path.concat([_vname]));\n  }\n  const scriptCacheKey = this.currEval + 'Script:' + code;\n  if (!JSONPath.cache[scriptCacheKey]) {\n    let script = code.replaceAll('@parentProperty', '_$_parentProperty').replaceAll('@parent', '_$_parent').replaceAll('@property', '_$_property').replaceAll('@root', '_$_root').replaceAll(/@([.\\s)[])/gu, '_$_v$1');\n    if (containsPath) {\n      script = script.replaceAll('@path', '_$_path');\n    }\n    if (this.currEval === 'safe' || this.currEval === true || this.currEval === undefined) {\n      JSONPath.cache[scriptCacheKey] = new this.safeVm.Script(script);\n    } else if (this.currEval === 'native') {\n      JSONPath.cache[scriptCacheKey] = new this.vm.Script(script);\n    } else if (typeof this.currEval === 'function' && this.currEval.prototype && Object.hasOwn(this.currEval.prototype, 'runInNewContext')) {\n      const CurrEval = this.currEval;\n      JSONPath.cache[scriptCacheKey] = new CurrEval(script);\n    } else if (typeof this.currEval === 'function') {\n      JSONPath.cache[scriptCacheKey] = {\n        runInNewContext: context => this.currEval(script, context)\n      };\n    } else {\n      throw new TypeError(`Unknown \"eval\" property \"${this.currEval}\"`);\n    }\n  }\n  try {\n    return JSONPath.cache[scriptCacheKey].runInNewContext(this.currSandbox);\n  } catch (e) {\n    if (this.ignoreEvalErrors) {\n      return false;\n    }\n    throw new Error('jsonPath: ' + e.message + ': ' + code);\n  }\n};\n\n// PUBLIC CLASS PROPERTIES AND METHODS\n\n// Could store the cache object itself\nJSONPath.cache = {};\n\n/**\n * @param {string[]} pathArr Array to convert\n * @returns {string} The path string\n */\nJSONPath.toPathString = function (pathArr) {\n  const x = pathArr,\n    n = x.length;\n  let p = '$';\n  for (let i = 1; i < n; i++) {\n    if (!/^(~|\\^|@.*?\\(\\))$/u.test(x[i])) {\n      p += /^[0-9*]+$/u.test(x[i]) ? '[' + x[i] + ']' : \"['\" + x[i] + \"']\";\n    }\n  }\n  return p;\n};\n\n/**\n * @param {string} pointer JSON Path\n * @returns {string} JSON Pointer\n */\nJSONPath.toPointer = function (pointer) {\n  const x = pointer,\n    n = x.length;\n  let p = '';\n  for (let i = 1; i < n; i++) {\n    if (!/^(~|\\^|@.*?\\(\\))$/u.test(x[i])) {\n      p += '/' + x[i].toString().replaceAll('~', '~0').replaceAll('/', '~1');\n    }\n  }\n  return p;\n};\n\n/**\n * @param {string} expr Expression to convert\n * @returns {string[]}\n */\nJSONPath.toPathArray = function (expr) {\n  const {\n    cache\n  } = JSONPath;\n  if (cache[expr]) {\n    return cache[expr].concat();\n  }\n  const subx = [];\n  const normalized = expr\n  // Properties\n  .replaceAll(/@(?:null|boolean|number|string|integer|undefined|nonFinite|scalar|array|object|function|other)\\(\\)/gu, ';$&;')\n  // Parenthetical evaluations (filtering and otherwise), directly\n  //   within brackets or single quotes\n  .replaceAll(/[['](\\??\\(.*?\\))[\\]'](?!.\\])/gu, function ($0, $1) {\n    return '[#' + (subx.push($1) - 1) + ']';\n  })\n  // Escape periods and tildes within properties\n  .replaceAll(/\\[['\"]([^'\\]]*)['\"]\\]/gu, function ($0, prop) {\n    return \"['\" + prop.replaceAll('.', '%@%').replaceAll('~', '%%@@%%') + \"']\";\n  })\n  // Properties operator\n  .replaceAll('~', ';~;')\n  // Split by property boundaries\n  .replaceAll(/['\"]?\\.['\"]?(?![^[]*\\])|\\[['\"]?/gu, ';')\n  // Reinsert periods within properties\n  .replaceAll('%@%', '.')\n  // Reinsert tildes within properties\n  .replaceAll('%%@@%%', '~')\n  // Parent\n  .replaceAll(/(?:;)?(\\^+)(?:;)?/gu, function ($0, ups) {\n    return ';' + ups.split('').join(';') + ';';\n  })\n  // Descendents\n  .replaceAll(/;;;|;;/gu, ';..;')\n  // Remove trailing\n  .replaceAll(/;$|'?\\]|'$/gu, '');\n  const exprList = normalized.split(';').map(function (exp) {\n    const match = exp.match(/#(\\d+)/u);\n    return !match || !match[1] ? exp : subx[match[1]];\n  });\n  cache[expr] = exprList;\n  return cache[expr].concat();\n};\nJSONPath.prototype.safeVm = {\n  Script: SafeScript\n};\n\n/**\n * @typedef {any} ContextItem\n */\n\n/**\n * @typedef {any} EvaluatedResult\n */\n\n/**\n * @callback ConditionCallback\n * @param {ContextItem} item\n * @returns {boolean}\n */\n\n/**\n * Copy items out of one array into another.\n * @param {GenericArray} source Array with items to copy\n * @param {GenericArray} target Array to which to copy\n * @param {ConditionCallback} conditionCb Callback passed the current item;\n *     will move item if evaluates to `true`\n * @returns {void}\n */\nconst moveToAnotherArray = function (source, target, conditionCb) {\n  const il = source.length;\n  for (let i = 0; i < il; i++) {\n    const item = source[i];\n    if (conditionCb(item)) {\n      // eslint-disable-next-line @stylistic/max-len -- Long\n      // eslint-disable-next-line sonarjs/updated-loop-counter -- Convenient\n      target.push(source.splice(i--, 1)[0]);\n    }\n  }\n};\n\n/**\n * In-browser replacement for NodeJS' VM.Script.\n */\nclass Script {\n  /**\n   * @param {string} expr Expression to evaluate\n   */\n  constructor(expr) {\n    this.code = expr;\n  }\n\n  /**\n   * @param {object} context Object whose items will be added\n   *   to evaluation\n   * @returns {EvaluatedResult} Result of evaluated code\n   */\n  runInNewContext(context) {\n    let expr = this.code;\n    const keys = Object.keys(context);\n    const funcs = [];\n    moveToAnotherArray(keys, funcs, key => {\n      return typeof context[key] === 'function';\n    });\n    const values = keys.map(vr => {\n      return context[vr];\n    });\n    const funcString = funcs.reduce((s, func) => {\n      let fString = context[func].toString();\n      if (!/function/u.test(fString)) {\n        fString = 'function ' + fString;\n      }\n      return 'var ' + func + '=' + fString + ';' + s;\n    }, '');\n    expr = funcString + expr;\n\n    // Mitigate http://perfectionkills.com/global-eval-what-are-the-options/#new_function\n    if (!/(['\"])use strict\\1/u.test(expr) && !keys.includes('arguments')) {\n      expr = 'var arguments = undefined;' + expr;\n    }\n\n    // Remove last semi so `return` will be inserted before\n    //  the previous one instead, allowing for the return\n    //  of a bare ending expression\n    expr = expr.replace(/;\\s*$/u, '');\n\n    // Insert `return`\n    const lastStatementEnd = expr.lastIndexOf(';');\n    const code = lastStatementEnd !== -1 ? expr.slice(0, lastStatementEnd + 1) + ' return ' + expr.slice(lastStatementEnd + 1) : ' return ' + expr;\n\n    // eslint-disable-next-line no-new-func -- User's choice\n    return new Function(...keys, code)(...values);\n  }\n}\nJSONPath.prototype.vm = {\n  Script\n};\nexport { JSONPath };","map":{"version":3,"names":["Hooks","add","name","callback","first","arguments","Array","isArray","forEach","run","env","call","context","Plugins","constructor","jsep","registered","register","_len","length","plugins","_key","plugin","init","Error","Jsep","version","toString","addUnaryOp","op_name","max_unop_len","Math","max","unary_ops","addBinaryOp","precedence","isRightAssociative","max_binop_len","binary_ops","right_associative","delete","addIdentifierChar","char","additional_identifier_chars","addLiteral","literal_name","literal_value","literals","removeUnaryOp","getMaxKeyLen","removeAllUnaryOps","removeIdentifierChar","removeBinaryOp","removeAllBinaryOps","removeLiteral","removeAllLiterals","expr","charAt","index","code","charCodeAt","parse","obj","Object","keys","map","k","isDecimalDigit","ch","binaryPrecedence","op_val","isIdentifierStart","String","fromCharCode","has","isIdentifierPart","throwError","message","error","description","runHook","node","hooks","searchHook","find","gobbleSpaces","SPACE_CODE","TAB_CODE","LF_CODE","CR_CODE","nodes","gobbleExpressions","type","COMPOUND","body","untilICode","ch_i","SEMCOL_CODE","COMMA_CODE","gobbleExpression","push","gobbleBinaryExpression","gobbleBinaryOp","to_check","substr","tc_len","hasOwnProperty","biop","prec","stack","biop_info","left","right","i","cur_biop","gobbleToken","value","right_a","comparePrev","prev","pop","BINARY_EXP","operator","PERIOD_CODE","gobbleNumericLiteral","SQUOTE_CODE","DQUOTE_CODE","gobbleStringLiteral","OBRACK_CODE","gobbleArray","argument","UNARY_EXP","prefix","gobbleIdentifier","LITERAL","raw","this_str","THIS_EXP","OPAREN_CODE","gobbleGroup","gobbleTokenProperty","QUMARK_CODE","optional","MEMBER_EXP","computed","object","property","CBRACK_CODE","CALL_EXP","gobbleArguments","CPAREN_CODE","callee","number","chCode","parseFloat","str","startIndex","quote","closed","substring","start","IDENTIFIER","slice","termination","args","separator_count","arg","SEQUENCE_EXP","expressions","ARRAY_EXP","elements","assign","COLON_CODE","Set","stdClassProps","getOwnPropertyNames","Test","filter","prop","includes","undefined","m","CONDITIONAL_EXP","ternary","gobbleTernary","test","consequent","alternate","newTest","FSLASH_CODE","BSLASH_CODE","gobbleRegexLiteral","patternIndex","inCharSet","pattern","flags","RegExp","e","PLUS_CODE","MINUS_CODE","assignmentOperators","updateOperators","assignmentPrecedence","updateNodeTypes","op","gobbleUpdatePrefix","some","c","gobbleUpdatePostfix","gobbleAssignment","updateBinariesToAssignments","values","val","BLOCKED_PROTO_PROPERTIES","SafeEval","evalAst","ast","subs","evalBinaryExpression","evalCompound","evalConditionalExpression","evalIdentifier","evalLiteral","evalMemberExpression","evalUnaryExpression","evalArrayExpression","evalCallExpression","evalAssignmentExpression","SyntaxError","result","||","a","b","&&","|","^","&","==","!=","===","!==","<",">","<=",">=","<<",">>",">>>","+","-","*","/","%","last","hasOwn","ReferenceError","TypeError","bind","typeof","el","func","id","SafeScript","runInNewContext","keyMap","create","arr","item","unshift","NewError","avoidNew","JSONPath","opts","otherTypeCallback","optObj","json","path","resultType","flatten","wrap","sandbox","eval","ignoreEvalErrors","parent","parentProperty","autostart","ret","evaluate","prototype","currParent","currParentProperty","currResultType","currEval","currSandbox","currOtherTypeCallback","toPathString","exprList","toPathArray","shift","_hasParentSelector","_trace","ea","isParentSelector","hasArrExpr","_getPreferredOutput","reduce","rslt","valOrPath","concat","pointer","toPointer","_handleCallback","fullRetObj","preferredOutput","parentPropName","literalPriority","retObj","loc","x","addRet","elems","t","_walk","_slice","indexOf","safeLoc","replace","nested","exec","npath","nvalue","filterResults","_eval","at","addType","valueType","Number","isFinite","locProp","parts","split","part","rett","tmp","tl","tt","splice","f","n","len","step","parseInt","end","min","_v","_vname","_$_parentProperty","_$_parent","_$_property","_$_root","_$_v","containsPath","_$_path","scriptCacheKey","cache","script","replaceAll","safeVm","Script","vm","CurrEval","pathArr","p","subx","normalized","$0","$1","ups","join","exp","match","moveToAnotherArray","source","target","conditionCb","il","funcs","key","vr","funcString","s","fString","lastStatementEnd","lastIndexOf","Function"],"sources":["C:/Users/abhis/OneDrive/Desktop/JSON TREE VISUALIZER/json-tree-visualizer/node_modules/jsonpath-plus/dist/index-browser-esm.js"],"sourcesContent":["/**\n * @implements {IHooks}\n */\nclass Hooks {\n  /**\n   * @callback HookCallback\n   * @this {*|Jsep} this\n   * @param {Jsep} env\n   * @returns: void\n   */\n  /**\n   * Adds the given callback to the list of callbacks for the given hook.\n   *\n   * The callback will be invoked when the hook it is registered for is run.\n   *\n   * One callback function can be registered to multiple hooks and the same hook multiple times.\n   *\n   * @param {string|object} name The name of the hook, or an object of callbacks keyed by name\n   * @param {HookCallback|boolean} callback The callback function which is given environment variables.\n   * @param {?boolean} [first=false] Will add the hook to the top of the list (defaults to the bottom)\n   * @public\n   */\n  add(name, callback, first) {\n    if (typeof arguments[0] != 'string') {\n      // Multiple hook callbacks, keyed by name\n      for (let name in arguments[0]) {\n        this.add(name, arguments[0][name], arguments[1]);\n      }\n    } else {\n      (Array.isArray(name) ? name : [name]).forEach(function (name) {\n        this[name] = this[name] || [];\n        if (callback) {\n          this[name][first ? 'unshift' : 'push'](callback);\n        }\n      }, this);\n    }\n  }\n\n  /**\n   * Runs a hook invoking all registered callbacks with the given environment variables.\n   *\n   * Callbacks will be invoked synchronously and in the order in which they were registered.\n   *\n   * @param {string} name The name of the hook.\n   * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\n   * @public\n   */\n  run(name, env) {\n    this[name] = this[name] || [];\n    this[name].forEach(function (callback) {\n      callback.call(env && env.context ? env.context : env, env);\n    });\n  }\n}\n\n/**\n * @implements {IPlugins}\n */\nclass Plugins {\n  constructor(jsep) {\n    this.jsep = jsep;\n    this.registered = {};\n  }\n\n  /**\n   * @callback PluginSetup\n   * @this {Jsep} jsep\n   * @returns: void\n   */\n  /**\n   * Adds the given plugin(s) to the registry\n   *\n   * @param {object} plugins\n   * @param {string} plugins.name The name of the plugin\n   * @param {PluginSetup} plugins.init The init function\n   * @public\n   */\n  register() {\n    for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {\n      plugins[_key] = arguments[_key];\n    }\n    plugins.forEach(plugin => {\n      if (typeof plugin !== 'object' || !plugin.name || !plugin.init) {\n        throw new Error('Invalid JSEP plugin format');\n      }\n      if (this.registered[plugin.name]) {\n        // already registered. Ignore.\n        return;\n      }\n      plugin.init(this.jsep);\n      this.registered[plugin.name] = plugin;\n    });\n  }\n}\n\n//     JavaScript Expression Parser (JSEP) 1.4.0\n\nclass Jsep {\n  /**\n   * @returns {string}\n   */\n  static get version() {\n    // To be filled in by the template\n    return '1.4.0';\n  }\n\n  /**\n   * @returns {string}\n   */\n  static toString() {\n    return 'JavaScript Expression Parser (JSEP) v' + Jsep.version;\n  }\n  // ==================== CONFIG ================================\n  /**\n   * @method addUnaryOp\n   * @param {string} op_name The name of the unary op to add\n   * @returns {Jsep}\n   */\n  static addUnaryOp(op_name) {\n    Jsep.max_unop_len = Math.max(op_name.length, Jsep.max_unop_len);\n    Jsep.unary_ops[op_name] = 1;\n    return Jsep;\n  }\n\n  /**\n   * @method jsep.addBinaryOp\n   * @param {string} op_name The name of the binary op to add\n   * @param {number} precedence The precedence of the binary op (can be a float). Higher number = higher precedence\n   * @param {boolean} [isRightAssociative=false] whether operator is right-associative\n   * @returns {Jsep}\n   */\n  static addBinaryOp(op_name, precedence, isRightAssociative) {\n    Jsep.max_binop_len = Math.max(op_name.length, Jsep.max_binop_len);\n    Jsep.binary_ops[op_name] = precedence;\n    if (isRightAssociative) {\n      Jsep.right_associative.add(op_name);\n    } else {\n      Jsep.right_associative.delete(op_name);\n    }\n    return Jsep;\n  }\n\n  /**\n   * @method addIdentifierChar\n   * @param {string} char The additional character to treat as a valid part of an identifier\n   * @returns {Jsep}\n   */\n  static addIdentifierChar(char) {\n    Jsep.additional_identifier_chars.add(char);\n    return Jsep;\n  }\n\n  /**\n   * @method addLiteral\n   * @param {string} literal_name The name of the literal to add\n   * @param {*} literal_value The value of the literal\n   * @returns {Jsep}\n   */\n  static addLiteral(literal_name, literal_value) {\n    Jsep.literals[literal_name] = literal_value;\n    return Jsep;\n  }\n\n  /**\n   * @method removeUnaryOp\n   * @param {string} op_name The name of the unary op to remove\n   * @returns {Jsep}\n   */\n  static removeUnaryOp(op_name) {\n    delete Jsep.unary_ops[op_name];\n    if (op_name.length === Jsep.max_unop_len) {\n      Jsep.max_unop_len = Jsep.getMaxKeyLen(Jsep.unary_ops);\n    }\n    return Jsep;\n  }\n\n  /**\n   * @method removeAllUnaryOps\n   * @returns {Jsep}\n   */\n  static removeAllUnaryOps() {\n    Jsep.unary_ops = {};\n    Jsep.max_unop_len = 0;\n    return Jsep;\n  }\n\n  /**\n   * @method removeIdentifierChar\n   * @param {string} char The additional character to stop treating as a valid part of an identifier\n   * @returns {Jsep}\n   */\n  static removeIdentifierChar(char) {\n    Jsep.additional_identifier_chars.delete(char);\n    return Jsep;\n  }\n\n  /**\n   * @method removeBinaryOp\n   * @param {string} op_name The name of the binary op to remove\n   * @returns {Jsep}\n   */\n  static removeBinaryOp(op_name) {\n    delete Jsep.binary_ops[op_name];\n    if (op_name.length === Jsep.max_binop_len) {\n      Jsep.max_binop_len = Jsep.getMaxKeyLen(Jsep.binary_ops);\n    }\n    Jsep.right_associative.delete(op_name);\n    return Jsep;\n  }\n\n  /**\n   * @method removeAllBinaryOps\n   * @returns {Jsep}\n   */\n  static removeAllBinaryOps() {\n    Jsep.binary_ops = {};\n    Jsep.max_binop_len = 0;\n    return Jsep;\n  }\n\n  /**\n   * @method removeLiteral\n   * @param {string} literal_name The name of the literal to remove\n   * @returns {Jsep}\n   */\n  static removeLiteral(literal_name) {\n    delete Jsep.literals[literal_name];\n    return Jsep;\n  }\n\n  /**\n   * @method removeAllLiterals\n   * @returns {Jsep}\n   */\n  static removeAllLiterals() {\n    Jsep.literals = {};\n    return Jsep;\n  }\n  // ==================== END CONFIG ============================\n\n  /**\n   * @returns {string}\n   */\n  get char() {\n    return this.expr.charAt(this.index);\n  }\n\n  /**\n   * @returns {number}\n   */\n  get code() {\n    return this.expr.charCodeAt(this.index);\n  }\n  /**\n   * @param {string} expr a string with the passed in express\n   * @returns Jsep\n   */\n  constructor(expr) {\n    // `index` stores the character number we are currently at\n    // All of the gobbles below will modify `index` as we move along\n    this.expr = expr;\n    this.index = 0;\n  }\n\n  /**\n   * static top-level parser\n   * @returns {jsep.Expression}\n   */\n  static parse(expr) {\n    return new Jsep(expr).parse();\n  }\n\n  /**\n   * Get the longest key length of any object\n   * @param {object} obj\n   * @returns {number}\n   */\n  static getMaxKeyLen(obj) {\n    return Math.max(0, ...Object.keys(obj).map(k => k.length));\n  }\n\n  /**\n   * `ch` is a character code in the next three functions\n   * @param {number} ch\n   * @returns {boolean}\n   */\n  static isDecimalDigit(ch) {\n    return ch >= 48 && ch <= 57; // 0...9\n  }\n\n  /**\n   * Returns the precedence of a binary operator or `0` if it isn't a binary operator. Can be float.\n   * @param {string} op_val\n   * @returns {number}\n   */\n  static binaryPrecedence(op_val) {\n    return Jsep.binary_ops[op_val] || 0;\n  }\n\n  /**\n   * Looks for start of identifier\n   * @param {number} ch\n   * @returns {boolean}\n   */\n  static isIdentifierStart(ch) {\n    return ch >= 65 && ch <= 90 ||\n    // A...Z\n    ch >= 97 && ch <= 122 ||\n    // a...z\n    ch >= 128 && !Jsep.binary_ops[String.fromCharCode(ch)] ||\n    // any non-ASCII that is not an operator\n    Jsep.additional_identifier_chars.has(String.fromCharCode(ch)); // additional characters\n  }\n\n  /**\n   * @param {number} ch\n   * @returns {boolean}\n   */\n  static isIdentifierPart(ch) {\n    return Jsep.isIdentifierStart(ch) || Jsep.isDecimalDigit(ch);\n  }\n\n  /**\n   * throw error at index of the expression\n   * @param {string} message\n   * @throws\n   */\n  throwError(message) {\n    const error = new Error(message + ' at character ' + this.index);\n    error.index = this.index;\n    error.description = message;\n    throw error;\n  }\n\n  /**\n   * Run a given hook\n   * @param {string} name\n   * @param {jsep.Expression|false} [node]\n   * @returns {?jsep.Expression}\n   */\n  runHook(name, node) {\n    if (Jsep.hooks[name]) {\n      const env = {\n        context: this,\n        node\n      };\n      Jsep.hooks.run(name, env);\n      return env.node;\n    }\n    return node;\n  }\n\n  /**\n   * Runs a given hook until one returns a node\n   * @param {string} name\n   * @returns {?jsep.Expression}\n   */\n  searchHook(name) {\n    if (Jsep.hooks[name]) {\n      const env = {\n        context: this\n      };\n      Jsep.hooks[name].find(function (callback) {\n        callback.call(env.context, env);\n        return env.node;\n      });\n      return env.node;\n    }\n  }\n\n  /**\n   * Push `index` up to the next non-space character\n   */\n  gobbleSpaces() {\n    let ch = this.code;\n    // Whitespace\n    while (ch === Jsep.SPACE_CODE || ch === Jsep.TAB_CODE || ch === Jsep.LF_CODE || ch === Jsep.CR_CODE) {\n      ch = this.expr.charCodeAt(++this.index);\n    }\n    this.runHook('gobble-spaces');\n  }\n\n  /**\n   * Top-level method to parse all expressions and returns compound or single node\n   * @returns {jsep.Expression}\n   */\n  parse() {\n    this.runHook('before-all');\n    const nodes = this.gobbleExpressions();\n\n    // If there's only one expression just try returning the expression\n    const node = nodes.length === 1 ? nodes[0] : {\n      type: Jsep.COMPOUND,\n      body: nodes\n    };\n    return this.runHook('after-all', node);\n  }\n\n  /**\n   * top-level parser (but can be reused within as well)\n   * @param {number} [untilICode]\n   * @returns {jsep.Expression[]}\n   */\n  gobbleExpressions(untilICode) {\n    let nodes = [],\n      ch_i,\n      node;\n    while (this.index < this.expr.length) {\n      ch_i = this.code;\n\n      // Expressions can be separated by semicolons, commas, or just inferred without any\n      // separators\n      if (ch_i === Jsep.SEMCOL_CODE || ch_i === Jsep.COMMA_CODE) {\n        this.index++; // ignore separators\n      } else {\n        // Try to gobble each expression individually\n        if (node = this.gobbleExpression()) {\n          nodes.push(node);\n          // If we weren't able to find a binary expression and are out of room, then\n          // the expression passed in probably has too much\n        } else if (this.index < this.expr.length) {\n          if (ch_i === untilICode) {\n            break;\n          }\n          this.throwError('Unexpected \"' + this.char + '\"');\n        }\n      }\n    }\n    return nodes;\n  }\n\n  /**\n   * The main parsing function.\n   * @returns {?jsep.Expression}\n   */\n  gobbleExpression() {\n    const node = this.searchHook('gobble-expression') || this.gobbleBinaryExpression();\n    this.gobbleSpaces();\n    return this.runHook('after-expression', node);\n  }\n\n  /**\n   * Search for the operation portion of the string (e.g. `+`, `===`)\n   * Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)\n   * and move down from 3 to 2 to 1 character until a matching binary operation is found\n   * then, return that binary operation\n   * @returns {string|boolean}\n   */\n  gobbleBinaryOp() {\n    this.gobbleSpaces();\n    let to_check = this.expr.substr(this.index, Jsep.max_binop_len);\n    let tc_len = to_check.length;\n    while (tc_len > 0) {\n      // Don't accept a binary op when it is an identifier.\n      // Binary ops that start with a identifier-valid character must be followed\n      // by a non identifier-part valid character\n      if (Jsep.binary_ops.hasOwnProperty(to_check) && (!Jsep.isIdentifierStart(this.code) || this.index + to_check.length < this.expr.length && !Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))) {\n        this.index += tc_len;\n        return to_check;\n      }\n      to_check = to_check.substr(0, --tc_len);\n    }\n    return false;\n  }\n\n  /**\n   * This function is responsible for gobbling an individual expression,\n   * e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`\n   * @returns {?jsep.BinaryExpression}\n   */\n  gobbleBinaryExpression() {\n    let node, biop, prec, stack, biop_info, left, right, i, cur_biop;\n\n    // First, try to get the leftmost thing\n    // Then, check to see if there's a binary operator operating on that leftmost thing\n    // Don't gobbleBinaryOp without a left-hand-side\n    left = this.gobbleToken();\n    if (!left) {\n      return left;\n    }\n    biop = this.gobbleBinaryOp();\n\n    // If there wasn't a binary operator, just return the leftmost node\n    if (!biop) {\n      return left;\n    }\n\n    // Otherwise, we need to start a stack to properly place the binary operations in their\n    // precedence structure\n    biop_info = {\n      value: biop,\n      prec: Jsep.binaryPrecedence(biop),\n      right_a: Jsep.right_associative.has(biop)\n    };\n    right = this.gobbleToken();\n    if (!right) {\n      this.throwError(\"Expected expression after \" + biop);\n    }\n    stack = [left, biop_info, right];\n\n    // Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)\n    while (biop = this.gobbleBinaryOp()) {\n      prec = Jsep.binaryPrecedence(biop);\n      if (prec === 0) {\n        this.index -= biop.length;\n        break;\n      }\n      biop_info = {\n        value: biop,\n        prec,\n        right_a: Jsep.right_associative.has(biop)\n      };\n      cur_biop = biop;\n\n      // Reduce: make a binary expression from the three topmost entries.\n      const comparePrev = prev => biop_info.right_a && prev.right_a ? prec > prev.prec : prec <= prev.prec;\n      while (stack.length > 2 && comparePrev(stack[stack.length - 2])) {\n        right = stack.pop();\n        biop = stack.pop().value;\n        left = stack.pop();\n        node = {\n          type: Jsep.BINARY_EXP,\n          operator: biop,\n          left,\n          right\n        };\n        stack.push(node);\n      }\n      node = this.gobbleToken();\n      if (!node) {\n        this.throwError(\"Expected expression after \" + cur_biop);\n      }\n      stack.push(biop_info, node);\n    }\n    i = stack.length - 1;\n    node = stack[i];\n    while (i > 1) {\n      node = {\n        type: Jsep.BINARY_EXP,\n        operator: stack[i - 1].value,\n        left: stack[i - 2],\n        right: node\n      };\n      i -= 2;\n    }\n    return node;\n  }\n\n  /**\n   * An individual part of a binary expression:\n   * e.g. `foo.bar(baz)`, `1`, `\"abc\"`, `(a % 2)` (because it's in parenthesis)\n   * @returns {boolean|jsep.Expression}\n   */\n  gobbleToken() {\n    let ch, to_check, tc_len, node;\n    this.gobbleSpaces();\n    node = this.searchHook('gobble-token');\n    if (node) {\n      return this.runHook('after-token', node);\n    }\n    ch = this.code;\n    if (Jsep.isDecimalDigit(ch) || ch === Jsep.PERIOD_CODE) {\n      // Char code 46 is a dot `.` which can start off a numeric literal\n      return this.gobbleNumericLiteral();\n    }\n    if (ch === Jsep.SQUOTE_CODE || ch === Jsep.DQUOTE_CODE) {\n      // Single or double quotes\n      node = this.gobbleStringLiteral();\n    } else if (ch === Jsep.OBRACK_CODE) {\n      node = this.gobbleArray();\n    } else {\n      to_check = this.expr.substr(this.index, Jsep.max_unop_len);\n      tc_len = to_check.length;\n      while (tc_len > 0) {\n        // Don't accept an unary op when it is an identifier.\n        // Unary ops that start with a identifier-valid character must be followed\n        // by a non identifier-part valid character\n        if (Jsep.unary_ops.hasOwnProperty(to_check) && (!Jsep.isIdentifierStart(this.code) || this.index + to_check.length < this.expr.length && !Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))) {\n          this.index += tc_len;\n          const argument = this.gobbleToken();\n          if (!argument) {\n            this.throwError('missing unaryOp argument');\n          }\n          return this.runHook('after-token', {\n            type: Jsep.UNARY_EXP,\n            operator: to_check,\n            argument,\n            prefix: true\n          });\n        }\n        to_check = to_check.substr(0, --tc_len);\n      }\n      if (Jsep.isIdentifierStart(ch)) {\n        node = this.gobbleIdentifier();\n        if (Jsep.literals.hasOwnProperty(node.name)) {\n          node = {\n            type: Jsep.LITERAL,\n            value: Jsep.literals[node.name],\n            raw: node.name\n          };\n        } else if (node.name === Jsep.this_str) {\n          node = {\n            type: Jsep.THIS_EXP\n          };\n        }\n      } else if (ch === Jsep.OPAREN_CODE) {\n        // open parenthesis\n        node = this.gobbleGroup();\n      }\n    }\n    if (!node) {\n      return this.runHook('after-token', false);\n    }\n    node = this.gobbleTokenProperty(node);\n    return this.runHook('after-token', node);\n  }\n\n  /**\n   * Gobble properties of of identifiers/strings/arrays/groups.\n   * e.g. `foo`, `bar.baz`, `foo['bar'].baz`\n   * It also gobbles function calls:\n   * e.g. `Math.acos(obj.angle)`\n   * @param {jsep.Expression} node\n   * @returns {jsep.Expression}\n   */\n  gobbleTokenProperty(node) {\n    this.gobbleSpaces();\n    let ch = this.code;\n    while (ch === Jsep.PERIOD_CODE || ch === Jsep.OBRACK_CODE || ch === Jsep.OPAREN_CODE || ch === Jsep.QUMARK_CODE) {\n      let optional;\n      if (ch === Jsep.QUMARK_CODE) {\n        if (this.expr.charCodeAt(this.index + 1) !== Jsep.PERIOD_CODE) {\n          break;\n        }\n        optional = true;\n        this.index += 2;\n        this.gobbleSpaces();\n        ch = this.code;\n      }\n      this.index++;\n      if (ch === Jsep.OBRACK_CODE) {\n        node = {\n          type: Jsep.MEMBER_EXP,\n          computed: true,\n          object: node,\n          property: this.gobbleExpression()\n        };\n        if (!node.property) {\n          this.throwError('Unexpected \"' + this.char + '\"');\n        }\n        this.gobbleSpaces();\n        ch = this.code;\n        if (ch !== Jsep.CBRACK_CODE) {\n          this.throwError('Unclosed [');\n        }\n        this.index++;\n      } else if (ch === Jsep.OPAREN_CODE) {\n        // A function call is being made; gobble all the arguments\n        node = {\n          type: Jsep.CALL_EXP,\n          'arguments': this.gobbleArguments(Jsep.CPAREN_CODE),\n          callee: node\n        };\n      } else if (ch === Jsep.PERIOD_CODE || optional) {\n        if (optional) {\n          this.index--;\n        }\n        this.gobbleSpaces();\n        node = {\n          type: Jsep.MEMBER_EXP,\n          computed: false,\n          object: node,\n          property: this.gobbleIdentifier()\n        };\n      }\n      if (optional) {\n        node.optional = true;\n      } // else leave undefined for compatibility with esprima\n\n      this.gobbleSpaces();\n      ch = this.code;\n    }\n    return node;\n  }\n\n  /**\n   * Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to\n   * keep track of everything in the numeric literal and then calling `parseFloat` on that string\n   * @returns {jsep.Literal}\n   */\n  gobbleNumericLiteral() {\n    let number = '',\n      ch,\n      chCode;\n    while (Jsep.isDecimalDigit(this.code)) {\n      number += this.expr.charAt(this.index++);\n    }\n    if (this.code === Jsep.PERIOD_CODE) {\n      // can start with a decimal marker\n      number += this.expr.charAt(this.index++);\n      while (Jsep.isDecimalDigit(this.code)) {\n        number += this.expr.charAt(this.index++);\n      }\n    }\n    ch = this.char;\n    if (ch === 'e' || ch === 'E') {\n      // exponent marker\n      number += this.expr.charAt(this.index++);\n      ch = this.char;\n      if (ch === '+' || ch === '-') {\n        // exponent sign\n        number += this.expr.charAt(this.index++);\n      }\n      while (Jsep.isDecimalDigit(this.code)) {\n        // exponent itself\n        number += this.expr.charAt(this.index++);\n      }\n      if (!Jsep.isDecimalDigit(this.expr.charCodeAt(this.index - 1))) {\n        this.throwError('Expected exponent (' + number + this.char + ')');\n      }\n    }\n    chCode = this.code;\n\n    // Check to make sure this isn't a variable name that start with a number (123abc)\n    if (Jsep.isIdentifierStart(chCode)) {\n      this.throwError('Variable names cannot start with a number (' + number + this.char + ')');\n    } else if (chCode === Jsep.PERIOD_CODE || number.length === 1 && number.charCodeAt(0) === Jsep.PERIOD_CODE) {\n      this.throwError('Unexpected period');\n    }\n    return {\n      type: Jsep.LITERAL,\n      value: parseFloat(number),\n      raw: number\n    };\n  }\n\n  /**\n   * Parses a string literal, staring with single or double quotes with basic support for escape codes\n   * e.g. `\"hello world\"`, `'this is\\nJSEP'`\n   * @returns {jsep.Literal}\n   */\n  gobbleStringLiteral() {\n    let str = '';\n    const startIndex = this.index;\n    const quote = this.expr.charAt(this.index++);\n    let closed = false;\n    while (this.index < this.expr.length) {\n      let ch = this.expr.charAt(this.index++);\n      if (ch === quote) {\n        closed = true;\n        break;\n      } else if (ch === '\\\\') {\n        // Check for all of the common escape codes\n        ch = this.expr.charAt(this.index++);\n        switch (ch) {\n          case 'n':\n            str += '\\n';\n            break;\n          case 'r':\n            str += '\\r';\n            break;\n          case 't':\n            str += '\\t';\n            break;\n          case 'b':\n            str += '\\b';\n            break;\n          case 'f':\n            str += '\\f';\n            break;\n          case 'v':\n            str += '\\x0B';\n            break;\n          default:\n            str += ch;\n        }\n      } else {\n        str += ch;\n      }\n    }\n    if (!closed) {\n      this.throwError('Unclosed quote after \"' + str + '\"');\n    }\n    return {\n      type: Jsep.LITERAL,\n      value: str,\n      raw: this.expr.substring(startIndex, this.index)\n    };\n  }\n\n  /**\n   * Gobbles only identifiers\n   * e.g.: `foo`, `_value`, `$x1`\n   * Also, this function checks if that identifier is a literal:\n   * (e.g. `true`, `false`, `null`) or `this`\n   * @returns {jsep.Identifier}\n   */\n  gobbleIdentifier() {\n    let ch = this.code,\n      start = this.index;\n    if (Jsep.isIdentifierStart(ch)) {\n      this.index++;\n    } else {\n      this.throwError('Unexpected ' + this.char);\n    }\n    while (this.index < this.expr.length) {\n      ch = this.code;\n      if (Jsep.isIdentifierPart(ch)) {\n        this.index++;\n      } else {\n        break;\n      }\n    }\n    return {\n      type: Jsep.IDENTIFIER,\n      name: this.expr.slice(start, this.index)\n    };\n  }\n\n  /**\n   * Gobbles a list of arguments within the context of a function call\n   * or array literal. This function also assumes that the opening character\n   * `(` or `[` has already been gobbled, and gobbles expressions and commas\n   * until the terminator character `)` or `]` is encountered.\n   * e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`\n   * @param {number} termination\n   * @returns {jsep.Expression[]}\n   */\n  gobbleArguments(termination) {\n    const args = [];\n    let closed = false;\n    let separator_count = 0;\n    while (this.index < this.expr.length) {\n      this.gobbleSpaces();\n      let ch_i = this.code;\n      if (ch_i === termination) {\n        // done parsing\n        closed = true;\n        this.index++;\n        if (termination === Jsep.CPAREN_CODE && separator_count && separator_count >= args.length) {\n          this.throwError('Unexpected token ' + String.fromCharCode(termination));\n        }\n        break;\n      } else if (ch_i === Jsep.COMMA_CODE) {\n        // between expressions\n        this.index++;\n        separator_count++;\n        if (separator_count !== args.length) {\n          // missing argument\n          if (termination === Jsep.CPAREN_CODE) {\n            this.throwError('Unexpected token ,');\n          } else if (termination === Jsep.CBRACK_CODE) {\n            for (let arg = args.length; arg < separator_count; arg++) {\n              args.push(null);\n            }\n          }\n        }\n      } else if (args.length !== separator_count && separator_count !== 0) {\n        // NOTE: `&& separator_count !== 0` allows for either all commas, or all spaces as arguments\n        this.throwError('Expected comma');\n      } else {\n        const node = this.gobbleExpression();\n        if (!node || node.type === Jsep.COMPOUND) {\n          this.throwError('Expected comma');\n        }\n        args.push(node);\n      }\n    }\n    if (!closed) {\n      this.throwError('Expected ' + String.fromCharCode(termination));\n    }\n    return args;\n  }\n\n  /**\n   * Responsible for parsing a group of things within parentheses `()`\n   * that have no identifier in front (so not a function call)\n   * This function assumes that it needs to gobble the opening parenthesis\n   * and then tries to gobble everything within that parenthesis, assuming\n   * that the next thing it should see is the close parenthesis. If not,\n   * then the expression probably doesn't have a `)`\n   * @returns {boolean|jsep.Expression}\n   */\n  gobbleGroup() {\n    this.index++;\n    let nodes = this.gobbleExpressions(Jsep.CPAREN_CODE);\n    if (this.code === Jsep.CPAREN_CODE) {\n      this.index++;\n      if (nodes.length === 1) {\n        return nodes[0];\n      } else if (!nodes.length) {\n        return false;\n      } else {\n        return {\n          type: Jsep.SEQUENCE_EXP,\n          expressions: nodes\n        };\n      }\n    } else {\n      this.throwError('Unclosed (');\n    }\n  }\n\n  /**\n   * Responsible for parsing Array literals `[1, 2, 3]`\n   * This function assumes that it needs to gobble the opening bracket\n   * and then tries to gobble the expressions as arguments.\n   * @returns {jsep.ArrayExpression}\n   */\n  gobbleArray() {\n    this.index++;\n    return {\n      type: Jsep.ARRAY_EXP,\n      elements: this.gobbleArguments(Jsep.CBRACK_CODE)\n    };\n  }\n}\n\n// Static fields:\nconst hooks = new Hooks();\nObject.assign(Jsep, {\n  hooks,\n  plugins: new Plugins(Jsep),\n  // Node Types\n  // ----------\n  // This is the full set of types that any JSEP node can be.\n  // Store them here to save space when minified\n  COMPOUND: 'Compound',\n  SEQUENCE_EXP: 'SequenceExpression',\n  IDENTIFIER: 'Identifier',\n  MEMBER_EXP: 'MemberExpression',\n  LITERAL: 'Literal',\n  THIS_EXP: 'ThisExpression',\n  CALL_EXP: 'CallExpression',\n  UNARY_EXP: 'UnaryExpression',\n  BINARY_EXP: 'BinaryExpression',\n  ARRAY_EXP: 'ArrayExpression',\n  TAB_CODE: 9,\n  LF_CODE: 10,\n  CR_CODE: 13,\n  SPACE_CODE: 32,\n  PERIOD_CODE: 46,\n  // '.'\n  COMMA_CODE: 44,\n  // ','\n  SQUOTE_CODE: 39,\n  // single quote\n  DQUOTE_CODE: 34,\n  // double quotes\n  OPAREN_CODE: 40,\n  // (\n  CPAREN_CODE: 41,\n  // )\n  OBRACK_CODE: 91,\n  // [\n  CBRACK_CODE: 93,\n  // ]\n  QUMARK_CODE: 63,\n  // ?\n  SEMCOL_CODE: 59,\n  // ;\n  COLON_CODE: 58,\n  // :\n\n  // Operations\n  // ----------\n  // Use a quickly-accessible map to store all of the unary operators\n  // Values are set to `1` (it really doesn't matter)\n  unary_ops: {\n    '-': 1,\n    '!': 1,\n    '~': 1,\n    '+': 1\n  },\n  // Also use a map for the binary operations but set their values to their\n  // binary precedence for quick reference (higher number = higher precedence)\n  // see [Order of operations](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)\n  binary_ops: {\n    '||': 1,\n    '??': 1,\n    '&&': 2,\n    '|': 3,\n    '^': 4,\n    '&': 5,\n    '==': 6,\n    '!=': 6,\n    '===': 6,\n    '!==': 6,\n    '<': 7,\n    '>': 7,\n    '<=': 7,\n    '>=': 7,\n    '<<': 8,\n    '>>': 8,\n    '>>>': 8,\n    '+': 9,\n    '-': 9,\n    '*': 10,\n    '/': 10,\n    '%': 10,\n    '**': 11\n  },\n  // sets specific binary_ops as right-associative\n  right_associative: new Set(['**']),\n  // Additional valid identifier chars, apart from a-z, A-Z and 0-9 (except on the starting char)\n  additional_identifier_chars: new Set(['$', '_']),\n  // Literals\n  // ----------\n  // Store the values to return for the various literals we may encounter\n  literals: {\n    'true': true,\n    'false': false,\n    'null': null\n  },\n  // Except for `this`, which is special. This could be changed to something like `'self'` as well\n  this_str: 'this'\n});\nJsep.max_unop_len = Jsep.getMaxKeyLen(Jsep.unary_ops);\nJsep.max_binop_len = Jsep.getMaxKeyLen(Jsep.binary_ops);\n\n// Backward Compatibility:\nconst jsep = expr => new Jsep(expr).parse();\nconst stdClassProps = Object.getOwnPropertyNames(class Test {});\nObject.getOwnPropertyNames(Jsep).filter(prop => !stdClassProps.includes(prop) && jsep[prop] === undefined).forEach(m => {\n  jsep[m] = Jsep[m];\n});\njsep.Jsep = Jsep; // allows for const { Jsep } = require('jsep');\n\nconst CONDITIONAL_EXP = 'ConditionalExpression';\nvar ternary = {\n  name: 'ternary',\n  init(jsep) {\n    // Ternary expression: test ? consequent : alternate\n    jsep.hooks.add('after-expression', function gobbleTernary(env) {\n      if (env.node && this.code === jsep.QUMARK_CODE) {\n        this.index++;\n        const test = env.node;\n        const consequent = this.gobbleExpression();\n        if (!consequent) {\n          this.throwError('Expected expression');\n        }\n        this.gobbleSpaces();\n        if (this.code === jsep.COLON_CODE) {\n          this.index++;\n          const alternate = this.gobbleExpression();\n          if (!alternate) {\n            this.throwError('Expected expression');\n          }\n          env.node = {\n            type: CONDITIONAL_EXP,\n            test,\n            consequent,\n            alternate\n          };\n\n          // check for operators of higher priority than ternary (i.e. assignment)\n          // jsep sets || at 1, and assignment at 0.9, and conditional should be between them\n          if (test.operator && jsep.binary_ops[test.operator] <= 0.9) {\n            let newTest = test;\n            while (newTest.right.operator && jsep.binary_ops[newTest.right.operator] <= 0.9) {\n              newTest = newTest.right;\n            }\n            env.node.test = newTest.right;\n            newTest.right = env.node;\n            env.node = test;\n          }\n        } else {\n          this.throwError('Expected :');\n        }\n      }\n    });\n  }\n};\n\n// Add default plugins:\n\njsep.plugins.register(ternary);\n\nconst FSLASH_CODE = 47; // '/'\nconst BSLASH_CODE = 92; // '\\\\'\n\nvar index = {\n  name: 'regex',\n  init(jsep) {\n    // Regex literal: /abc123/ig\n    jsep.hooks.add('gobble-token', function gobbleRegexLiteral(env) {\n      if (this.code === FSLASH_CODE) {\n        const patternIndex = ++this.index;\n        let inCharSet = false;\n        while (this.index < this.expr.length) {\n          if (this.code === FSLASH_CODE && !inCharSet) {\n            const pattern = this.expr.slice(patternIndex, this.index);\n            let flags = '';\n            while (++this.index < this.expr.length) {\n              const code = this.code;\n              if (code >= 97 && code <= 122 // a...z\n              || code >= 65 && code <= 90 // A...Z\n              || code >= 48 && code <= 57) {\n                // 0-9\n                flags += this.char;\n              } else {\n                break;\n              }\n            }\n            let value;\n            try {\n              value = new RegExp(pattern, flags);\n            } catch (e) {\n              this.throwError(e.message);\n            }\n            env.node = {\n              type: jsep.LITERAL,\n              value,\n              raw: this.expr.slice(patternIndex - 1, this.index)\n            };\n\n            // allow . [] and () after regex: /regex/.test(a)\n            env.node = this.gobbleTokenProperty(env.node);\n            return env.node;\n          }\n          if (this.code === jsep.OBRACK_CODE) {\n            inCharSet = true;\n          } else if (inCharSet && this.code === jsep.CBRACK_CODE) {\n            inCharSet = false;\n          }\n          this.index += this.code === BSLASH_CODE ? 2 : 1;\n        }\n        this.throwError('Unclosed Regex');\n      }\n    });\n  }\n};\n\nconst PLUS_CODE = 43; // +\nconst MINUS_CODE = 45; // -\n\nconst plugin = {\n  name: 'assignment',\n  assignmentOperators: new Set(['=', '*=', '**=', '/=', '%=', '+=', '-=', '<<=', '>>=', '>>>=', '&=', '^=', '|=', '||=', '&&=', '??=']),\n  updateOperators: [PLUS_CODE, MINUS_CODE],\n  assignmentPrecedence: 0.9,\n  init(jsep) {\n    const updateNodeTypes = [jsep.IDENTIFIER, jsep.MEMBER_EXP];\n    plugin.assignmentOperators.forEach(op => jsep.addBinaryOp(op, plugin.assignmentPrecedence, true));\n    jsep.hooks.add('gobble-token', function gobbleUpdatePrefix(env) {\n      const code = this.code;\n      if (plugin.updateOperators.some(c => c === code && c === this.expr.charCodeAt(this.index + 1))) {\n        this.index += 2;\n        env.node = {\n          type: 'UpdateExpression',\n          operator: code === PLUS_CODE ? '++' : '--',\n          argument: this.gobbleTokenProperty(this.gobbleIdentifier()),\n          prefix: true\n        };\n        if (!env.node.argument || !updateNodeTypes.includes(env.node.argument.type)) {\n          this.throwError(`Unexpected ${env.node.operator}`);\n        }\n      }\n    });\n    jsep.hooks.add('after-token', function gobbleUpdatePostfix(env) {\n      if (env.node) {\n        const code = this.code;\n        if (plugin.updateOperators.some(c => c === code && c === this.expr.charCodeAt(this.index + 1))) {\n          if (!updateNodeTypes.includes(env.node.type)) {\n            this.throwError(`Unexpected ${env.node.operator}`);\n          }\n          this.index += 2;\n          env.node = {\n            type: 'UpdateExpression',\n            operator: code === PLUS_CODE ? '++' : '--',\n            argument: env.node,\n            prefix: false\n          };\n        }\n      }\n    });\n    jsep.hooks.add('after-expression', function gobbleAssignment(env) {\n      if (env.node) {\n        // Note: Binaries can be chained in a single expression to respect\n        // operator precedence (i.e. a = b = 1 + 2 + 3)\n        // Update all binary assignment nodes in the tree\n        updateBinariesToAssignments(env.node);\n      }\n    });\n    function updateBinariesToAssignments(node) {\n      if (plugin.assignmentOperators.has(node.operator)) {\n        node.type = 'AssignmentExpression';\n        updateBinariesToAssignments(node.left);\n        updateBinariesToAssignments(node.right);\n      } else if (!node.operator) {\n        Object.values(node).forEach(val => {\n          if (val && typeof val === 'object') {\n            updateBinariesToAssignments(val);\n          }\n        });\n      }\n    }\n  }\n};\n\n/* eslint-disable no-bitwise -- Convenient */\n\n// register plugins\njsep.plugins.register(index, plugin);\njsep.addUnaryOp('typeof');\njsep.addLiteral('null', null);\njsep.addLiteral('undefined', undefined);\nconst BLOCKED_PROTO_PROPERTIES = new Set(['constructor', '__proto__', '__defineGetter__', '__defineSetter__']);\nconst SafeEval = {\n  /**\n   * @param {jsep.Expression} ast\n   * @param {Record<string, any>} subs\n   */\n  evalAst(ast, subs) {\n    switch (ast.type) {\n      case 'BinaryExpression':\n      case 'LogicalExpression':\n        return SafeEval.evalBinaryExpression(ast, subs);\n      case 'Compound':\n        return SafeEval.evalCompound(ast, subs);\n      case 'ConditionalExpression':\n        return SafeEval.evalConditionalExpression(ast, subs);\n      case 'Identifier':\n        return SafeEval.evalIdentifier(ast, subs);\n      case 'Literal':\n        return SafeEval.evalLiteral(ast, subs);\n      case 'MemberExpression':\n        return SafeEval.evalMemberExpression(ast, subs);\n      case 'UnaryExpression':\n        return SafeEval.evalUnaryExpression(ast, subs);\n      case 'ArrayExpression':\n        return SafeEval.evalArrayExpression(ast, subs);\n      case 'CallExpression':\n        return SafeEval.evalCallExpression(ast, subs);\n      case 'AssignmentExpression':\n        return SafeEval.evalAssignmentExpression(ast, subs);\n      default:\n        throw SyntaxError('Unexpected expression', ast);\n    }\n  },\n  evalBinaryExpression(ast, subs) {\n    const result = {\n      '||': (a, b) => a || b(),\n      '&&': (a, b) => a && b(),\n      '|': (a, b) => a | b(),\n      '^': (a, b) => a ^ b(),\n      '&': (a, b) => a & b(),\n      // eslint-disable-next-line eqeqeq -- API\n      '==': (a, b) => a == b(),\n      // eslint-disable-next-line eqeqeq -- API\n      '!=': (a, b) => a != b(),\n      '===': (a, b) => a === b(),\n      '!==': (a, b) => a !== b(),\n      '<': (a, b) => a < b(),\n      '>': (a, b) => a > b(),\n      '<=': (a, b) => a <= b(),\n      '>=': (a, b) => a >= b(),\n      '<<': (a, b) => a << b(),\n      '>>': (a, b) => a >> b(),\n      '>>>': (a, b) => a >>> b(),\n      '+': (a, b) => a + b(),\n      '-': (a, b) => a - b(),\n      '*': (a, b) => a * b(),\n      '/': (a, b) => a / b(),\n      '%': (a, b) => a % b()\n    }[ast.operator](SafeEval.evalAst(ast.left, subs), () => SafeEval.evalAst(ast.right, subs));\n    return result;\n  },\n  evalCompound(ast, subs) {\n    let last;\n    for (let i = 0; i < ast.body.length; i++) {\n      if (ast.body[i].type === 'Identifier' && ['var', 'let', 'const'].includes(ast.body[i].name) && ast.body[i + 1] && ast.body[i + 1].type === 'AssignmentExpression') {\n        // var x=2; is detected as\n        // [{Identifier var}, {AssignmentExpression x=2}]\n        // eslint-disable-next-line @stylistic/max-len -- Long\n        // eslint-disable-next-line sonarjs/updated-loop-counter -- Convenient\n        i += 1;\n      }\n      const expr = ast.body[i];\n      last = SafeEval.evalAst(expr, subs);\n    }\n    return last;\n  },\n  evalConditionalExpression(ast, subs) {\n    if (SafeEval.evalAst(ast.test, subs)) {\n      return SafeEval.evalAst(ast.consequent, subs);\n    }\n    return SafeEval.evalAst(ast.alternate, subs);\n  },\n  evalIdentifier(ast, subs) {\n    if (Object.hasOwn(subs, ast.name)) {\n      return subs[ast.name];\n    }\n    throw ReferenceError(`${ast.name} is not defined`);\n  },\n  evalLiteral(ast) {\n    return ast.value;\n  },\n  evalMemberExpression(ast, subs) {\n    const prop = String(\n    // NOTE: `String(value)` throws error when\n    // value has overwritten the toString method to return non-string\n    // i.e. `value = {toString: () => []}`\n    ast.computed ? SafeEval.evalAst(ast.property) // `object[property]`\n    : ast.property.name // `object.property` property is Identifier\n    );\n    const obj = SafeEval.evalAst(ast.object, subs);\n    if (obj === undefined || obj === null) {\n      throw TypeError(`Cannot read properties of ${obj} (reading '${prop}')`);\n    }\n    if (!Object.hasOwn(obj, prop) && BLOCKED_PROTO_PROPERTIES.has(prop)) {\n      throw TypeError(`Cannot read properties of ${obj} (reading '${prop}')`);\n    }\n    const result = obj[prop];\n    if (typeof result === 'function') {\n      return result.bind(obj); // arrow functions aren't affected by bind.\n    }\n    return result;\n  },\n  evalUnaryExpression(ast, subs) {\n    const result = {\n      '-': a => -SafeEval.evalAst(a, subs),\n      '!': a => !SafeEval.evalAst(a, subs),\n      '~': a => ~SafeEval.evalAst(a, subs),\n      // eslint-disable-next-line no-implicit-coercion -- API\n      '+': a => +SafeEval.evalAst(a, subs),\n      typeof: a => typeof SafeEval.evalAst(a, subs)\n    }[ast.operator](ast.argument);\n    return result;\n  },\n  evalArrayExpression(ast, subs) {\n    return ast.elements.map(el => SafeEval.evalAst(el, subs));\n  },\n  evalCallExpression(ast, subs) {\n    const args = ast.arguments.map(arg => SafeEval.evalAst(arg, subs));\n    const func = SafeEval.evalAst(ast.callee, subs);\n    // if (func === Function) {\n    //     throw new Error('Function constructor is disabled');\n    // }\n    return func(...args);\n  },\n  evalAssignmentExpression(ast, subs) {\n    if (ast.left.type !== 'Identifier') {\n      throw SyntaxError('Invalid left-hand side in assignment');\n    }\n    const id = ast.left.name;\n    const value = SafeEval.evalAst(ast.right, subs);\n    subs[id] = value;\n    return subs[id];\n  }\n};\n\n/**\n * A replacement for NodeJS' VM.Script which is also {@link https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP | Content Security Policy} friendly.\n */\nclass SafeScript {\n  /**\n   * @param {string} expr Expression to evaluate\n   */\n  constructor(expr) {\n    this.code = expr;\n    this.ast = jsep(this.code);\n  }\n\n  /**\n   * @param {object} context Object whose items will be added\n   *   to evaluation\n   * @returns {EvaluatedResult} Result of evaluated code\n   */\n  runInNewContext(context) {\n    // `Object.create(null)` creates a prototypeless object\n    const keyMap = Object.assign(Object.create(null), context);\n    return SafeEval.evalAst(this.ast, keyMap);\n  }\n}\n\n/* eslint-disable camelcase -- Convenient for escaping */\n\n\n/**\n * @typedef {null|boolean|number|string|object|GenericArray} JSONObject\n */\n\n/**\n * @typedef {any} AnyItem\n */\n\n/**\n * @typedef {any} AnyResult\n */\n\n/**\n * Copies array and then pushes item into it.\n * @param {GenericArray} arr Array to copy and into which to push\n * @param {AnyItem} item Array item to add (to end)\n * @returns {GenericArray} Copy of the original array\n */\nfunction push(arr, item) {\n  arr = arr.slice();\n  arr.push(item);\n  return arr;\n}\n/**\n * Copies array and then unshifts item into it.\n * @param {AnyItem} item Array item to add (to beginning)\n * @param {GenericArray} arr Array to copy and into which to unshift\n * @returns {GenericArray} Copy of the original array\n */\nfunction unshift(item, arr) {\n  arr = arr.slice();\n  arr.unshift(item);\n  return arr;\n}\n\n/**\n * Caught when JSONPath is used without `new` but rethrown if with `new`\n * @extends Error\n */\nclass NewError extends Error {\n  /**\n   * @param {AnyResult} value The evaluated scalar value\n   */\n  constructor(value) {\n    super('JSONPath should not be called with \"new\" (it prevents return ' + 'of (unwrapped) scalar values)');\n    this.avoidNew = true;\n    this.value = value;\n    this.name = 'NewError';\n  }\n}\n\n/**\n* @typedef {object} ReturnObject\n* @property {string} path\n* @property {JSONObject} value\n* @property {object|GenericArray} parent\n* @property {string} parentProperty\n*/\n\n/**\n* @callback JSONPathCallback\n* @param {string|object} preferredOutput\n* @param {\"value\"|\"property\"} type\n* @param {ReturnObject} fullRetObj\n* @returns {void}\n*/\n\n/**\n* @callback OtherTypeCallback\n* @param {JSONObject} val\n* @param {string} path\n* @param {object|GenericArray} parent\n* @param {string} parentPropName\n* @returns {boolean}\n*/\n\n/**\n * @typedef {any} ContextItem\n */\n\n/**\n * @typedef {any} EvaluatedResult\n */\n\n/**\n* @callback EvalCallback\n* @param {string} code\n* @param {ContextItem} context\n* @returns {EvaluatedResult}\n*/\n\n/**\n * @typedef {typeof SafeScript} EvalClass\n */\n\n/**\n * @typedef {object} JSONPathOptions\n * @property {JSON} json\n * @property {string|string[]} path\n * @property {\"value\"|\"path\"|\"pointer\"|\"parent\"|\"parentProperty\"|\n *   \"all\"} [resultType=\"value\"]\n * @property {boolean} [flatten=false]\n * @property {boolean} [wrap=true]\n * @property {object} [sandbox={}]\n * @property {EvalCallback|EvalClass|'safe'|'native'|\n *   boolean} [eval = 'safe']\n * @property {object|GenericArray|null} [parent=null]\n * @property {string|null} [parentProperty=null]\n * @property {JSONPathCallback} [callback]\n * @property {OtherTypeCallback} [otherTypeCallback] Defaults to\n *   function which throws on encountering `@other`\n * @property {boolean} [autostart=true]\n */\n\n/**\n * @param {string|JSONPathOptions} opts If a string, will be treated as `expr`\n * @param {string} [expr] JSON path to evaluate\n * @param {JSON} [obj] JSON object to evaluate against\n * @param {JSONPathCallback} [callback] Passed 3 arguments: 1) desired payload\n *     per `resultType`, 2) `\"value\"|\"property\"`, 3) Full returned object with\n *     all payloads\n * @param {OtherTypeCallback} [otherTypeCallback] If `@other()` is at the end\n *   of one's query, this will be invoked with the value of the item, its\n *   path, its parent, and its parent's property name, and it should return\n *   a boolean indicating whether the supplied value belongs to the \"other\"\n *   type or not (or it may handle transformations and return `false`).\n * @returns {JSONPath}\n * @class\n */\nfunction JSONPath(opts, expr, obj, callback, otherTypeCallback) {\n  // eslint-disable-next-line no-restricted-syntax -- Allow for pseudo-class\n  if (!(this instanceof JSONPath)) {\n    try {\n      return new JSONPath(opts, expr, obj, callback, otherTypeCallback);\n    } catch (e) {\n      if (!e.avoidNew) {\n        throw e;\n      }\n      return e.value;\n    }\n  }\n  if (typeof opts === 'string') {\n    otherTypeCallback = callback;\n    callback = obj;\n    obj = expr;\n    expr = opts;\n    opts = null;\n  }\n  const optObj = opts && typeof opts === 'object';\n  opts = opts || {};\n  this.json = opts.json || obj;\n  this.path = opts.path || expr;\n  this.resultType = opts.resultType || 'value';\n  this.flatten = opts.flatten || false;\n  this.wrap = Object.hasOwn(opts, 'wrap') ? opts.wrap : true;\n  this.sandbox = opts.sandbox || {};\n  this.eval = opts.eval === undefined ? 'safe' : opts.eval;\n  this.ignoreEvalErrors = typeof opts.ignoreEvalErrors === 'undefined' ? false : opts.ignoreEvalErrors;\n  this.parent = opts.parent || null;\n  this.parentProperty = opts.parentProperty || null;\n  this.callback = opts.callback || callback || null;\n  this.otherTypeCallback = opts.otherTypeCallback || otherTypeCallback || function () {\n    throw new TypeError('You must supply an otherTypeCallback callback option ' + 'with the @other() operator.');\n  };\n  if (opts.autostart !== false) {\n    const args = {\n      path: optObj ? opts.path : expr\n    };\n    if (!optObj) {\n      args.json = obj;\n    } else if ('json' in opts) {\n      args.json = opts.json;\n    }\n    const ret = this.evaluate(args);\n    if (!ret || typeof ret !== 'object') {\n      throw new NewError(ret);\n    }\n    return ret;\n  }\n}\n\n// PUBLIC METHODS\nJSONPath.prototype.evaluate = function (expr, json, callback, otherTypeCallback) {\n  let currParent = this.parent,\n    currParentProperty = this.parentProperty;\n  let {\n    flatten,\n    wrap\n  } = this;\n  this.currResultType = this.resultType;\n  this.currEval = this.eval;\n  this.currSandbox = this.sandbox;\n  callback = callback || this.callback;\n  this.currOtherTypeCallback = otherTypeCallback || this.otherTypeCallback;\n  json = json || this.json;\n  expr = expr || this.path;\n  if (expr && typeof expr === 'object' && !Array.isArray(expr)) {\n    if (!expr.path && expr.path !== '') {\n      throw new TypeError('You must supply a \"path\" property when providing an object ' + 'argument to JSONPath.evaluate().');\n    }\n    if (!Object.hasOwn(expr, 'json')) {\n      throw new TypeError('You must supply a \"json\" property when providing an object ' + 'argument to JSONPath.evaluate().');\n    }\n    ({\n      json\n    } = expr);\n    flatten = Object.hasOwn(expr, 'flatten') ? expr.flatten : flatten;\n    this.currResultType = Object.hasOwn(expr, 'resultType') ? expr.resultType : this.currResultType;\n    this.currSandbox = Object.hasOwn(expr, 'sandbox') ? expr.sandbox : this.currSandbox;\n    wrap = Object.hasOwn(expr, 'wrap') ? expr.wrap : wrap;\n    this.currEval = Object.hasOwn(expr, 'eval') ? expr.eval : this.currEval;\n    callback = Object.hasOwn(expr, 'callback') ? expr.callback : callback;\n    this.currOtherTypeCallback = Object.hasOwn(expr, 'otherTypeCallback') ? expr.otherTypeCallback : this.currOtherTypeCallback;\n    currParent = Object.hasOwn(expr, 'parent') ? expr.parent : currParent;\n    currParentProperty = Object.hasOwn(expr, 'parentProperty') ? expr.parentProperty : currParentProperty;\n    expr = expr.path;\n  }\n  currParent = currParent || null;\n  currParentProperty = currParentProperty || null;\n  if (Array.isArray(expr)) {\n    expr = JSONPath.toPathString(expr);\n  }\n  if (!expr && expr !== '' || !json) {\n    return undefined;\n  }\n  const exprList = JSONPath.toPathArray(expr);\n  if (exprList[0] === '$' && exprList.length > 1) {\n    exprList.shift();\n  }\n  this._hasParentSelector = null;\n  const result = this._trace(exprList, json, ['$'], currParent, currParentProperty, callback).filter(function (ea) {\n    return ea && !ea.isParentSelector;\n  });\n  if (!result.length) {\n    return wrap ? [] : undefined;\n  }\n  if (!wrap && result.length === 1 && !result[0].hasArrExpr) {\n    return this._getPreferredOutput(result[0]);\n  }\n  return result.reduce((rslt, ea) => {\n    const valOrPath = this._getPreferredOutput(ea);\n    if (flatten && Array.isArray(valOrPath)) {\n      rslt = rslt.concat(valOrPath);\n    } else {\n      rslt.push(valOrPath);\n    }\n    return rslt;\n  }, []);\n};\n\n// PRIVATE METHODS\n\nJSONPath.prototype._getPreferredOutput = function (ea) {\n  const resultType = this.currResultType;\n  switch (resultType) {\n    case 'all':\n      {\n        const path = Array.isArray(ea.path) ? ea.path : JSONPath.toPathArray(ea.path);\n        ea.pointer = JSONPath.toPointer(path);\n        ea.path = typeof ea.path === 'string' ? ea.path : JSONPath.toPathString(ea.path);\n        return ea;\n      }\n    case 'value':\n    case 'parent':\n    case 'parentProperty':\n      return ea[resultType];\n    case 'path':\n      return JSONPath.toPathString(ea[resultType]);\n    case 'pointer':\n      return JSONPath.toPointer(ea.path);\n    default:\n      throw new TypeError('Unknown result type');\n  }\n};\nJSONPath.prototype._handleCallback = function (fullRetObj, callback, type) {\n  if (callback) {\n    const preferredOutput = this._getPreferredOutput(fullRetObj);\n    fullRetObj.path = typeof fullRetObj.path === 'string' ? fullRetObj.path : JSONPath.toPathString(fullRetObj.path);\n    // eslint-disable-next-line n/callback-return -- No need to return\n    callback(preferredOutput, type, fullRetObj);\n  }\n};\n\n/**\n *\n * @param {string} expr\n * @param {JSONObject} val\n * @param {string} path\n * @param {object|GenericArray} parent\n * @param {string} parentPropName\n * @param {JSONPathCallback} callback\n * @param {boolean} hasArrExpr\n * @param {boolean} literalPriority\n * @returns {ReturnObject|ReturnObject[]}\n */\nJSONPath.prototype._trace = function (expr, val, path, parent, parentPropName, callback, hasArrExpr, literalPriority) {\n  // No expr to follow? return path and value as the result of\n  //  this trace branch\n  let retObj;\n  if (!expr.length) {\n    retObj = {\n      path,\n      value: val,\n      parent,\n      parentProperty: parentPropName,\n      hasArrExpr\n    };\n    this._handleCallback(retObj, callback, 'value');\n    return retObj;\n  }\n  const loc = expr[0],\n    x = expr.slice(1);\n\n  // We need to gather the return value of recursive trace calls in order to\n  // do the parent sel computation.\n  const ret = [];\n  /**\n   *\n   * @param {ReturnObject|ReturnObject[]} elems\n   * @returns {void}\n   */\n  function addRet(elems) {\n    if (Array.isArray(elems)) {\n      // This was causing excessive stack size in Node (with or\n      //  without Babel) against our performance test:\n      //  `ret.push(...elems);`\n      elems.forEach(t => {\n        ret.push(t);\n      });\n    } else {\n      ret.push(elems);\n    }\n  }\n  if ((typeof loc !== 'string' || literalPriority) && val && Object.hasOwn(val, loc)) {\n    // simple case--directly follow property\n    addRet(this._trace(x, val[loc], push(path, loc), val, loc, callback, hasArrExpr));\n    // eslint-disable-next-line unicorn/prefer-switch -- Part of larger `if`\n  } else if (loc === '*') {\n    // all child properties\n    this._walk(val, m => {\n      addRet(this._trace(x, val[m], push(path, m), val, m, callback, true, true));\n    });\n  } else if (loc === '..') {\n    // all descendent parent properties\n    // Check remaining expression with val's immediate children\n    addRet(this._trace(x, val, path, parent, parentPropName, callback, hasArrExpr));\n    this._walk(val, m => {\n      // We don't join m and x here because we only want parents,\n      //   not scalar values\n      if (typeof val[m] === 'object') {\n        // Keep going with recursive descent on val's\n        //   object children\n        addRet(this._trace(expr.slice(), val[m], push(path, m), val, m, callback, true));\n      }\n    });\n    // The parent sel computation is handled in the frame above using the\n    // ancestor object of val\n  } else if (loc === '^') {\n    // This is not a final endpoint, so we do not invoke the callback here\n    this._hasParentSelector = true;\n    return {\n      path: path.slice(0, -1),\n      expr: x,\n      isParentSelector: true\n    };\n  } else if (loc === '~') {\n    // property name\n    retObj = {\n      path: push(path, loc),\n      value: parentPropName,\n      parent,\n      parentProperty: null\n    };\n    this._handleCallback(retObj, callback, 'property');\n    return retObj;\n  } else if (loc === '$') {\n    // root only\n    addRet(this._trace(x, val, path, null, null, callback, hasArrExpr));\n  } else if (/^(-?\\d*):(-?\\d*):?(\\d*)$/u.test(loc)) {\n    // [start:end:step]  Python slice syntax\n    addRet(this._slice(loc, x, val, path, parent, parentPropName, callback));\n  } else if (loc.indexOf('?(') === 0) {\n    // [?(expr)] (filtering)\n    if (this.currEval === false) {\n      throw new Error('Eval [?(expr)] prevented in JSONPath expression.');\n    }\n    const safeLoc = loc.replace(/^\\?\\((.*?)\\)$/u, '$1');\n    // check for a nested filter expression\n    const nested = /@.?([^?]*)[['](\\??\\(.*?\\))(?!.\\)\\])[\\]']/gu.exec(safeLoc);\n    if (nested) {\n      // find if there are matches in the nested expression\n      // add them to the result set if there is at least one match\n      this._walk(val, m => {\n        const npath = [nested[2]];\n        const nvalue = nested[1] ? val[m][nested[1]] : val[m];\n        const filterResults = this._trace(npath, nvalue, path, parent, parentPropName, callback, true);\n        if (filterResults.length > 0) {\n          addRet(this._trace(x, val[m], push(path, m), val, m, callback, true));\n        }\n      });\n    } else {\n      this._walk(val, m => {\n        if (this._eval(safeLoc, val[m], m, path, parent, parentPropName)) {\n          addRet(this._trace(x, val[m], push(path, m), val, m, callback, true));\n        }\n      });\n    }\n  } else if (loc[0] === '(') {\n    // [(expr)] (dynamic property/index)\n    if (this.currEval === false) {\n      throw new Error('Eval [(expr)] prevented in JSONPath expression.');\n    }\n    // As this will resolve to a property name (but we don't know it\n    //  yet), property and parent information is relative to the\n    //  parent of the property to which this expression will resolve\n    addRet(this._trace(unshift(this._eval(loc, val, path.at(-1), path.slice(0, -1), parent, parentPropName), x), val, path, parent, parentPropName, callback, hasArrExpr));\n  } else if (loc[0] === '@') {\n    // value type: @boolean(), etc.\n    let addType = false;\n    const valueType = loc.slice(1, -2);\n    switch (valueType) {\n      case 'scalar':\n        if (!val || !['object', 'function'].includes(typeof val)) {\n          addType = true;\n        }\n        break;\n      case 'boolean':\n      case 'string':\n      case 'undefined':\n      case 'function':\n        if (typeof val === valueType) {\n          addType = true;\n        }\n        break;\n      case 'integer':\n        if (Number.isFinite(val) && !(val % 1)) {\n          addType = true;\n        }\n        break;\n      case 'number':\n        if (Number.isFinite(val)) {\n          addType = true;\n        }\n        break;\n      case 'nonFinite':\n        if (typeof val === 'number' && !Number.isFinite(val)) {\n          addType = true;\n        }\n        break;\n      case 'object':\n        if (val && typeof val === valueType) {\n          addType = true;\n        }\n        break;\n      case 'array':\n        if (Array.isArray(val)) {\n          addType = true;\n        }\n        break;\n      case 'other':\n        addType = this.currOtherTypeCallback(val, path, parent, parentPropName);\n        break;\n      case 'null':\n        if (val === null) {\n          addType = true;\n        }\n        break;\n      /* c8 ignore next 2 */\n      default:\n        throw new TypeError('Unknown value type ' + valueType);\n    }\n    if (addType) {\n      retObj = {\n        path,\n        value: val,\n        parent,\n        parentProperty: parentPropName\n      };\n      this._handleCallback(retObj, callback, 'value');\n      return retObj;\n    }\n    // `-escaped property\n  } else if (loc[0] === '`' && val && Object.hasOwn(val, loc.slice(1))) {\n    const locProp = loc.slice(1);\n    addRet(this._trace(x, val[locProp], push(path, locProp), val, locProp, callback, hasArrExpr, true));\n  } else if (loc.includes(',')) {\n    // [name1,name2,...]\n    const parts = loc.split(',');\n    for (const part of parts) {\n      addRet(this._trace(unshift(part, x), val, path, parent, parentPropName, callback, true));\n    }\n    // simple case--directly follow property\n  } else if (!literalPriority && val && Object.hasOwn(val, loc)) {\n    addRet(this._trace(x, val[loc], push(path, loc), val, loc, callback, hasArrExpr, true));\n  }\n\n  // We check the resulting values for parent selections. For parent\n  // selections we discard the value object and continue the trace with the\n  // current val object\n  if (this._hasParentSelector) {\n    for (let t = 0; t < ret.length; t++) {\n      const rett = ret[t];\n      if (rett && rett.isParentSelector) {\n        const tmp = this._trace(rett.expr, val, rett.path, parent, parentPropName, callback, hasArrExpr);\n        if (Array.isArray(tmp)) {\n          ret[t] = tmp[0];\n          const tl = tmp.length;\n          for (let tt = 1; tt < tl; tt++) {\n            // eslint-disable-next-line @stylistic/max-len -- Long\n            // eslint-disable-next-line sonarjs/updated-loop-counter -- Convenient\n            t++;\n            ret.splice(t, 0, tmp[tt]);\n          }\n        } else {\n          ret[t] = tmp;\n        }\n      }\n    }\n  }\n  return ret;\n};\nJSONPath.prototype._walk = function (val, f) {\n  if (Array.isArray(val)) {\n    const n = val.length;\n    for (let i = 0; i < n; i++) {\n      f(i);\n    }\n  } else if (val && typeof val === 'object') {\n    Object.keys(val).forEach(m => {\n      f(m);\n    });\n  }\n};\nJSONPath.prototype._slice = function (loc, expr, val, path, parent, parentPropName, callback) {\n  if (!Array.isArray(val)) {\n    return undefined;\n  }\n  const len = val.length,\n    parts = loc.split(':'),\n    step = parts[2] && Number.parseInt(parts[2]) || 1;\n  let start = parts[0] && Number.parseInt(parts[0]) || 0,\n    end = parts[1] && Number.parseInt(parts[1]) || len;\n  start = start < 0 ? Math.max(0, start + len) : Math.min(len, start);\n  end = end < 0 ? Math.max(0, end + len) : Math.min(len, end);\n  const ret = [];\n  for (let i = start; i < end; i += step) {\n    const tmp = this._trace(unshift(i, expr), val, path, parent, parentPropName, callback, true);\n    // Should only be possible to be an array here since first part of\n    //   ``unshift(i, expr)` passed in above would not be empty, nor `~`,\n    //     nor begin with `@` (as could return objects)\n    // This was causing excessive stack size in Node (with or\n    //  without Babel) against our performance test: `ret.push(...tmp);`\n    tmp.forEach(t => {\n      ret.push(t);\n    });\n  }\n  return ret;\n};\nJSONPath.prototype._eval = function (code, _v, _vname, path, parent, parentPropName) {\n  this.currSandbox._$_parentProperty = parentPropName;\n  this.currSandbox._$_parent = parent;\n  this.currSandbox._$_property = _vname;\n  this.currSandbox._$_root = this.json;\n  this.currSandbox._$_v = _v;\n  const containsPath = code.includes('@path');\n  if (containsPath) {\n    this.currSandbox._$_path = JSONPath.toPathString(path.concat([_vname]));\n  }\n  const scriptCacheKey = this.currEval + 'Script:' + code;\n  if (!JSONPath.cache[scriptCacheKey]) {\n    let script = code.replaceAll('@parentProperty', '_$_parentProperty').replaceAll('@parent', '_$_parent').replaceAll('@property', '_$_property').replaceAll('@root', '_$_root').replaceAll(/@([.\\s)[])/gu, '_$_v$1');\n    if (containsPath) {\n      script = script.replaceAll('@path', '_$_path');\n    }\n    if (this.currEval === 'safe' || this.currEval === true || this.currEval === undefined) {\n      JSONPath.cache[scriptCacheKey] = new this.safeVm.Script(script);\n    } else if (this.currEval === 'native') {\n      JSONPath.cache[scriptCacheKey] = new this.vm.Script(script);\n    } else if (typeof this.currEval === 'function' && this.currEval.prototype && Object.hasOwn(this.currEval.prototype, 'runInNewContext')) {\n      const CurrEval = this.currEval;\n      JSONPath.cache[scriptCacheKey] = new CurrEval(script);\n    } else if (typeof this.currEval === 'function') {\n      JSONPath.cache[scriptCacheKey] = {\n        runInNewContext: context => this.currEval(script, context)\n      };\n    } else {\n      throw new TypeError(`Unknown \"eval\" property \"${this.currEval}\"`);\n    }\n  }\n  try {\n    return JSONPath.cache[scriptCacheKey].runInNewContext(this.currSandbox);\n  } catch (e) {\n    if (this.ignoreEvalErrors) {\n      return false;\n    }\n    throw new Error('jsonPath: ' + e.message + ': ' + code);\n  }\n};\n\n// PUBLIC CLASS PROPERTIES AND METHODS\n\n// Could store the cache object itself\nJSONPath.cache = {};\n\n/**\n * @param {string[]} pathArr Array to convert\n * @returns {string} The path string\n */\nJSONPath.toPathString = function (pathArr) {\n  const x = pathArr,\n    n = x.length;\n  let p = '$';\n  for (let i = 1; i < n; i++) {\n    if (!/^(~|\\^|@.*?\\(\\))$/u.test(x[i])) {\n      p += /^[0-9*]+$/u.test(x[i]) ? '[' + x[i] + ']' : \"['\" + x[i] + \"']\";\n    }\n  }\n  return p;\n};\n\n/**\n * @param {string} pointer JSON Path\n * @returns {string} JSON Pointer\n */\nJSONPath.toPointer = function (pointer) {\n  const x = pointer,\n    n = x.length;\n  let p = '';\n  for (let i = 1; i < n; i++) {\n    if (!/^(~|\\^|@.*?\\(\\))$/u.test(x[i])) {\n      p += '/' + x[i].toString().replaceAll('~', '~0').replaceAll('/', '~1');\n    }\n  }\n  return p;\n};\n\n/**\n * @param {string} expr Expression to convert\n * @returns {string[]}\n */\nJSONPath.toPathArray = function (expr) {\n  const {\n    cache\n  } = JSONPath;\n  if (cache[expr]) {\n    return cache[expr].concat();\n  }\n  const subx = [];\n  const normalized = expr\n  // Properties\n  .replaceAll(/@(?:null|boolean|number|string|integer|undefined|nonFinite|scalar|array|object|function|other)\\(\\)/gu, ';$&;')\n  // Parenthetical evaluations (filtering and otherwise), directly\n  //   within brackets or single quotes\n  .replaceAll(/[['](\\??\\(.*?\\))[\\]'](?!.\\])/gu, function ($0, $1) {\n    return '[#' + (subx.push($1) - 1) + ']';\n  })\n  // Escape periods and tildes within properties\n  .replaceAll(/\\[['\"]([^'\\]]*)['\"]\\]/gu, function ($0, prop) {\n    return \"['\" + prop.replaceAll('.', '%@%').replaceAll('~', '%%@@%%') + \"']\";\n  })\n  // Properties operator\n  .replaceAll('~', ';~;')\n  // Split by property boundaries\n  .replaceAll(/['\"]?\\.['\"]?(?![^[]*\\])|\\[['\"]?/gu, ';')\n  // Reinsert periods within properties\n  .replaceAll('%@%', '.')\n  // Reinsert tildes within properties\n  .replaceAll('%%@@%%', '~')\n  // Parent\n  .replaceAll(/(?:;)?(\\^+)(?:;)?/gu, function ($0, ups) {\n    return ';' + ups.split('').join(';') + ';';\n  })\n  // Descendents\n  .replaceAll(/;;;|;;/gu, ';..;')\n  // Remove trailing\n  .replaceAll(/;$|'?\\]|'$/gu, '');\n  const exprList = normalized.split(';').map(function (exp) {\n    const match = exp.match(/#(\\d+)/u);\n    return !match || !match[1] ? exp : subx[match[1]];\n  });\n  cache[expr] = exprList;\n  return cache[expr].concat();\n};\nJSONPath.prototype.safeVm = {\n  Script: SafeScript\n};\n\n/**\n * @typedef {any} ContextItem\n */\n\n/**\n * @typedef {any} EvaluatedResult\n */\n\n/**\n * @callback ConditionCallback\n * @param {ContextItem} item\n * @returns {boolean}\n */\n\n/**\n * Copy items out of one array into another.\n * @param {GenericArray} source Array with items to copy\n * @param {GenericArray} target Array to which to copy\n * @param {ConditionCallback} conditionCb Callback passed the current item;\n *     will move item if evaluates to `true`\n * @returns {void}\n */\nconst moveToAnotherArray = function (source, target, conditionCb) {\n  const il = source.length;\n  for (let i = 0; i < il; i++) {\n    const item = source[i];\n    if (conditionCb(item)) {\n      // eslint-disable-next-line @stylistic/max-len -- Long\n      // eslint-disable-next-line sonarjs/updated-loop-counter -- Convenient\n      target.push(source.splice(i--, 1)[0]);\n    }\n  }\n};\n\n/**\n * In-browser replacement for NodeJS' VM.Script.\n */\nclass Script {\n  /**\n   * @param {string} expr Expression to evaluate\n   */\n  constructor(expr) {\n    this.code = expr;\n  }\n\n  /**\n   * @param {object} context Object whose items will be added\n   *   to evaluation\n   * @returns {EvaluatedResult} Result of evaluated code\n   */\n  runInNewContext(context) {\n    let expr = this.code;\n    const keys = Object.keys(context);\n    const funcs = [];\n    moveToAnotherArray(keys, funcs, key => {\n      return typeof context[key] === 'function';\n    });\n    const values = keys.map(vr => {\n      return context[vr];\n    });\n    const funcString = funcs.reduce((s, func) => {\n      let fString = context[func].toString();\n      if (!/function/u.test(fString)) {\n        fString = 'function ' + fString;\n      }\n      return 'var ' + func + '=' + fString + ';' + s;\n    }, '');\n    expr = funcString + expr;\n\n    // Mitigate http://perfectionkills.com/global-eval-what-are-the-options/#new_function\n    if (!/(['\"])use strict\\1/u.test(expr) && !keys.includes('arguments')) {\n      expr = 'var arguments = undefined;' + expr;\n    }\n\n    // Remove last semi so `return` will be inserted before\n    //  the previous one instead, allowing for the return\n    //  of a bare ending expression\n    expr = expr.replace(/;\\s*$/u, '');\n\n    // Insert `return`\n    const lastStatementEnd = expr.lastIndexOf(';');\n    const code = lastStatementEnd !== -1 ? expr.slice(0, lastStatementEnd + 1) + ' return ' + expr.slice(lastStatementEnd + 1) : ' return ' + expr;\n\n    // eslint-disable-next-line no-new-func -- User's choice\n    return new Function(...keys, code)(...values);\n  }\n}\nJSONPath.prototype.vm = {\n  Script\n};\n\nexport { JSONPath };\n"],"mappings":"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,MAAM,CAAC,IAAI,CAAC,EAAE7P,OAAO,CAAC;IAC1D,OAAO0M,QAAQ,CAACC,OAAO,CAAC,IAAI,CAACC,GAAG,EAAEgD,MAAM,CAAC;EAC3C;AACF;;AAEA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASpK,IAAIA,CAACsK,GAAG,EAAEC,IAAI,EAAE;EACvBD,GAAG,GAAGA,GAAG,CAACxG,KAAK,CAAC,CAAC;EACjBwG,GAAG,CAACtK,IAAI,CAACuK,IAAI,CAAC;EACd,OAAOD,GAAG;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,OAAOA,CAACD,IAAI,EAAED,GAAG,EAAE;EAC1BA,GAAG,GAAGA,GAAG,CAACxG,KAAK,CAAC,CAAC;EACjBwG,GAAG,CAACE,OAAO,CAACD,IAAI,CAAC;EACjB,OAAOD,GAAG;AACZ;;AAEA;AACA;AACA;AACA;AACA,MAAMG,QAAQ,SAASrP,KAAK,CAAC;EAC3B;AACF;AACA;EACEV,WAAWA,CAACsG,KAAK,EAAE;IACjB,KAAK,CAAC,+DAA+D,GAAG,+BAA+B,CAAC;IACxG,IAAI,CAAC0J,QAAQ,GAAG,IAAI;IACpB,IAAI,CAAC1J,KAAK,GAAGA,KAAK;IAClB,IAAI,CAAClH,IAAI,GAAG,UAAU;EACxB;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS6Q,QAAQA,CAACC,IAAI,EAAExN,IAAI,EAAEM,GAAG,EAA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}